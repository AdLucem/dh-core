
==================== FINAL INTERFACE ====================
2018-10-24 19:31:44.265552734 UTC

interface dense-linear-algebra-0.1.0.0-Elr9WMmlb0BKsm96yzG2PQ:Statistics.Matrix 8043
  interface hash: 529b6ceddec70b98a3e9cc181d23ce42
  ABI hash: 3a63c101721b545e487a706099b03953
  export-list hash: 0e7a49ec017dec644d0edf785c1c6228
  orphan hash: cb44fb76dd9d1240acdb608bfac548fd
  flag hash: 5a9dcc2a94025fb166a8ae8f55972489
  opt_hash: 14e536840aca4e889cad654e6f9b79c1
  hpc_hash: 93b885adfe0da089cdf634904fd59f71
  sig of: Nothing
  used TH splices: False
  where
exports:
  Statistics.Matrix.bounds
  Statistics.Matrix.center
  Statistics.Matrix.column
  Statistics.Matrix.diag
  Statistics.Matrix.dimension
  Statistics.Matrix.fromColumns
  Statistics.Matrix.fromList
  Statistics.Matrix.fromRowLists
  Statistics.Matrix.fromRows
  Statistics.Matrix.fromVector
  Statistics.Matrix.generate
  Statistics.Matrix.generateSym
  Statistics.Matrix.hasNaN
  Statistics.Matrix.ident
  Statistics.Matrix.map
  Statistics.Matrix.multiply
  Statistics.Matrix.multiplyV
  Statistics.Matrix.norm
  Statistics.Matrix.power
  Statistics.Matrix.row
  Statistics.Matrix.toColumns
  Statistics.Matrix.toList
  Statistics.Matrix.toRowLists
  Statistics.Matrix.toRows
  Statistics.Matrix.toVector
  Statistics.Matrix.transpose
  Statistics.Matrix.unsafeBounds
  Statistics.Matrix.unsafeIndex
  Statistics.Matrix.Function.for
  Statistics.Matrix.Types.Matrix{Statistics.Matrix.Types.Matrix _vector cols rows}
  Statistics.Matrix.Types.Vector
module dependencies: Statistics.Matrix.Function
                     Statistics.Matrix.Mutable Statistics.Matrix.Types
package dependencies: array-0.5.2.0 base-4.11.1.0 deepseq-1.4.3.0
                      ghc-boot-th-8.4.3 ghc-prim-0.5.2.0 integer-gmp-1.0.2.0
                      math-functions-0.2.1.0 pretty-1.1.3.6 primitive-0.6.3.0
                      template-haskell-2.13.0.0 transformers-0.5.5.0 vector-0.12.0.1
                      vector-th-unbox-0.2.1.6
orphans: vector-0.12.0.1:Data.Vector.Unboxed
         vector-0.12.0.1:Data.Vector.Fusion.Bundle
         transformers-0.5.5.0:Control.Monad.Trans.Error
         base-4.11.1.0:GHC.Float base-4.11.1.0:GHC.Base
family instance modules: base-4.11.1.0:Control.Applicative
                         base-4.11.1.0:Data.Complex base-4.11.1.0:Data.Functor.Compose
                         base-4.11.1.0:Data.Functor.Const
                         base-4.11.1.0:Data.Functor.Identity
                         base-4.11.1.0:Data.Functor.Product base-4.11.1.0:Data.Functor.Sum
                         base-4.11.1.0:Data.Monoid base-4.11.1.0:Data.Semigroup
                         base-4.11.1.0:Data.Semigroup.Internal base-4.11.1.0:Data.Version
                         base-4.11.1.0:Data.Void base-4.11.1.0:GHC.Exts
                         base-4.11.1.0:GHC.Generics base-4.11.1.0:GHC.IO.Exception
                         ghc-boot-th-8.4.3:GHC.ForeignSrcLang.Type
                         ghc-boot-th-8.4.3:GHC.LanguageExtensions.Type
                         math-functions-0.2.1.0:Numeric.Sum
                         pretty-1.1.3.6:Text.PrettyPrint.Annotated.HughesPJ
                         pretty-1.1.3.6:Text.PrettyPrint.HughesPJ
                         primitive-0.6.3.0:Control.Monad.Primitive
                         primitive-0.6.3.0:Data.Primitive.Array
                         primitive-0.6.3.0:Data.Primitive.ByteArray
                         template-haskell-2.13.0.0:Language.Haskell.TH.Syntax
                         vector-0.12.0.1:Data.Vector vector-0.12.0.1:Data.Vector.Primitive
                         vector-0.12.0.1:Data.Vector.Unboxed
                         vector-0.12.0.1:Data.Vector.Unboxed.Base
import  -/  base-4.11.1.0:Control.Applicative 55d9b3a7491623b0362290e162d67308
import  -/  base-4.11.1.0:Control.Monad.ST 27e5ac3d491e4d3e26d1ffd041e4f336
import  -/  base-4.11.1.0:Data.Foldable 8ed35c38958063956af33c935ea03444
import  -/  base-4.11.1.0:Data.Functor f522c3501272159820fd6f242510732f
import  -/  base-4.11.1.0:GHC.Base 604111500e81281298777e721c75643b
import  -/  base-4.11.1.0:GHC.Err 5e26aa744981f14e0f1e4d29c44ac52e
import  -/  base-4.11.1.0:GHC.Float 99c69d365bb2607725a22530ce1ca4b4
import  -/  base-4.11.1.0:GHC.List 1e4357702d8d00cded0703bd293e50e8
import  -/  base-4.11.1.0:GHC.Num 8e54b26dce4495382dc4b50cf36ab754
import  -/  base-4.11.1.0:GHC.Real b4beb0389ba1ad5d9640aae67848c5d3
import  -/  base-4.11.1.0:GHC.ST ead6e97aacc0df18581976b93def0d98
import  -/  base-4.11.1.0:GHC.Show 73be67392447c974f19c3befd83c46c0
import  -/  base-4.11.1.0:Prelude 0750c25585e2b797cd78291d423d39dd
import  -/  Statistics.Matrix.Function 381881e47389a9af84d8f32b55e971e1
  exports: 04d5cfd9fd8419c507fac6c3282d4d1b
  for 074cf03a6556069f9ad7c5f1ec443686
  square 3f8278ab985f7fd9fe94fd763c7d76b2
import  -/  Statistics.Matrix.Mutable a3afb366d571ff7d0f708aad29618100
  exports: 542f7194e4de18e23291e57bc34518f5
  unsafeFreeze 0cd77f9653863afbf399651298d3d693
  unsafeNew fd4f844466377b3bd414ef84357b9842
  unsafeWrite 78cd199d8e4612dcdb5f17190878629e
import  -/  Statistics.Matrix.Types 29068aaa03b39c75ee604070f2429116
  exports: 3c27e8e7cfdbdce7b7f35aa8883e527b
  Matrix 47b043d5ff102bde7f9c9d62d8f281aa
  Matrix cce97783d4e71efe03047af01f627ce0
  Vector e65f60b97b26d69ec79e5ef9c0024c9e
  _vector cce97783d4e71efe03047af01f627ce0
  cols cce97783d4e71efe03047af01f627ce0
  rows cce97783d4e71efe03047af01f627ce0
import  -/  ghc-prim-0.5.2.0:GHC.Classes 122abfcd7450c6c11602933c9ca5f80d
import  -/  math-functions-0.2.1.0:Numeric.Sum b21c47546d890b49ef36cd8cef8fea27
import  -/  vector-0.12.0.1:Data.Vector.Unboxed d2cefc1634a6760ea2d3b40a96cd1e81
import  -/  vector-0.12.0.1:Data.Vector.Unboxed.Base 94111a911b49f0bcabb45e8b44a71528
import  -/  vector-0.12.0.1:Data.Vector.Unboxed.Mutable d808ca83fe1744e975f73b50f5364eed
366a44f90f956f0616e7a9e2cbeedcfc
  $sunsafeIndex ::
    Data.Vector.Unboxed.Base.Vector GHC.Types.Double
    -> GHC.Types.Int -> GHC.Types.Double
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SLS),1*U(U,A,U)><S(S),1*U(U)>m,
     Inline: [1] (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ (v1 :: Data.Vector.Unboxed.Base.Vector GHC.Types.Double)
                   (i :: GHC.Types.Int) ->
                 case v1
                        `cast`
                      (Data.Vector.Unboxed.Base.D:R:VectorDouble0[0] ; Data.Vector.Unboxed.Base.N:R:VectorDouble[0]) of wild { Data.Vector.Primitive.Vector dt dt1 dt2 ->
                 case i of wild1 { GHC.Types.I# y ->
                 case GHC.Prim.indexDoubleArray#
                        dt2
                        (GHC.Prim.+# dt y) of wild2 { DEFAULT ->
                 (GHC.Types.D# wild2)
                   `cast`
                 (Sym (Data.Vector.Fusion.Util.N:Id[0] <GHC.Types.Double>_R)) } } })
                  `cast`
                (<Data.Vector.Unboxed.Base.Vector GHC.Types.Double>_R
                 ->_R <GHC.Types.Int>_R
                 ->_R Data.Vector.Fusion.Util.N:Id[0] <GHC.Types.Double>_R) -}
8454f25f648e54d41bac9ac3bb803daf
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   Statistics.Matrix.$trModule3
                   Statistics.Matrix.$trModule1) -}
5a9f22317dc900d0bb5250a500ab6ed9
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Statistics.Matrix.$trModule2) -}
4c4a2199d1fbcb429fe691b876f42b1a
  $trModule2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Statistics.Matrix"#) -}
ab1bba038835f3bcd6d9cc4bf5d8af9c
  $trModule3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Statistics.Matrix.$trModule4) -}
fdf6e26e8f882072caeb4a8f1d717e02
  $trModule4 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("dense-linear-algebra-0.1.0.0-Elr9WMmlb0BKsm96yzG2PQ"#) -}
f9c6ac73dae54808a173f1cf332ec91e
  $wdiag ::
    GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Prim.ByteArray#
    -> (# GHC.Prim.Int#, GHC.Prim.Int#,
          Statistics.Matrix.Types.Vector #)
  {- Arity: 3, Strictness: <L,U><S,U><L,U>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#)
                   (ww1 :: GHC.Prim.Int#)
                   (ww2 :: GHC.Prim.ByteArray#) ->
                 case GHC.Magic.runRW#
                        @ ('GHC.Types.TupleRep
                             '['GHC.Types.TupleRep '[], 'GHC.Types.LiftedRep])
                        @ (# GHC.Prim.State# GHC.Prim.RealWorld,
                             Data.Vector.Unboxed.Base.Vector GHC.Types.Double #)
                        (\ (s1 :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                         let {
                           y1 :: GHC.Prim.Int# = GHC.Prim.*# ww1 ww1
                         } in
                         let {
                           $j :: GHC.Prim.Int#
                                 -> GHC.Types.Int
                                 -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                       Data.Vector.Unboxed.Base.Vector GHC.Types.Double #)
                             <join 2> {- Arity: 2, Strictness: <S,U><L,A> -}
                           = \ (x :: GHC.Prim.Int#)[OneShot]
                               (wild :: GHC.Types.Int)[OneShot] ->
                             case GHC.Prim.<# x 0# of lwild {
                               DEFAULT
                               -> case GHC.Prim.># x 1152921504606846975# of lwild1 {
                                    DEFAULT
                                    -> case GHC.Prim.newByteArray#
                                              @ (Control.Monad.Primitive.PrimState
                                                   (GHC.ST.ST GHC.Prim.RealWorld))
                                              (GHC.Prim.*# x 8#)
                                              s1
                                                `cast`
                                              (GHC.Prim.State#
                                                 (Sym (Control.Monad.Primitive.D:R:PrimStateST[0]
                                                           <GHC.Prim.RealWorld>_N)))_R of ds1 { (#,#) ipv ipv1 ->
                                       case {__pkg_ccall primitive-0.6.3.0 forall s.
                                                                           GHC.Prim.MutableByteArray#
                                                                             s
                                                                           -> GHC.Prim.Int#
                                                                           -> GHC.Prim.Word#
                                                                           -> GHC.Prim.Double#
                                                                           -> GHC.Prim.State#
                                                                                GHC.Prim.RealWorld
                                                                           -> (# GHC.Prim.State#
                                                                                   GHC.Prim.RealWorld #)}
                                              @ (Control.Monad.Primitive.PrimState
                                                   (GHC.ST.ST GHC.Prim.RealWorld))
                                              ipv1
                                              0#
                                              (GHC.Prim.int2Word# x)
                                              0.0##
                                              ipv
                                                `cast`
                                              (GHC.Prim.State#
                                                 (Control.Monad.Primitive.D:R:PrimStateST[0]
                                                      <GHC.Prim.RealWorld>_N))_R of wild2 { Unit# ds9 ->
                                       let {
                                         exit :: GHC.Prim.Int#
                                                 -> GHC.Prim.Addr#
                                                 -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                                       Data.Vector.Unboxed.Base.Vector
                                                         GHC.Types.Double #)
                                           <join 2> {- Arity: 2, Strictness: <B,U><B,U>b -}
                                         = \ (ww3 :: GHC.Prim.Int#)[OneShot]
                                             (file :: GHC.Prim.Addr#)[OneShot] ->
                                           case Statistics.Matrix.diag5 ww1 ww3 file
                                           ret_ty (# GHC.Prim.State# GHC.Prim.RealWorld,
                                                     Data.Vector.Unboxed.Base.Vector
                                                       GHC.Types.Double #)
                                           of {}
                                       } in
                                       let {
                                         exit1 :: GHC.Prim.Int#
                                                  -> GHC.Prim.Addr#
                                                  -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                                        Data.Vector.Unboxed.Base.Vector
                                                          GHC.Types.Double #)
                                           <join 2> {- Arity: 2, Strictness: <B,U><B,U>b -}
                                         = \ (ww3 :: GHC.Prim.Int#)[OneShot]
                                             (file :: GHC.Prim.Addr#)[OneShot] ->
                                           case Statistics.Matrix.diag5 ww1 ww3 file
                                           ret_ty (# GHC.Prim.State# GHC.Prim.RealWorld,
                                                     Data.Vector.Unboxed.Base.Vector
                                                       GHC.Types.Double #)
                                           of {}
                                       } in
                                       let {
                                         exit2 :: GHC.Prim.State# GHC.Prim.RealWorld
                                                  -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                                        Data.Vector.Unboxed.Base.Vector
                                                          GHC.Types.Double #)
                                           <join 1> {- Arity: 1, Strictness: <S,U> -}
                                         = \ (w :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                                           case GHC.Prim.unsafeFreezeByteArray#
                                                  @ (Control.Monad.Primitive.PrimState
                                                       (GHC.ST.ST GHC.Prim.RealWorld))
                                                  ipv1
                                                  w `cast`
                                                  (GHC.Prim.State#
                                                     (Sym (Control.Monad.Primitive.D:R:PrimStateST[0]
                                                               <GHC.Prim.RealWorld>_N)))_R of ds2 { (#,#) ipv2 ipv3 ->
                                           (# ipv2
                                                `cast`
                                              (GHC.Prim.State#
                                                 (Control.Monad.Primitive.D:R:PrimStateST[0]
                                                      <GHC.Prim.RealWorld>_N))_R,
                                              (Data.Vector.Primitive.Vector
                                                 @ GHC.Types.Double
                                                 0#
                                                 x
                                                 ipv3)
                                                `cast`
                                              (Sym (Data.Vector.Unboxed.Base.N:R:VectorDouble[0]) ; Sym (Data.Vector.Unboxed.Base.D:R:VectorDouble0[0])) #) }
                                       } in
                                       letrec {
                                         $wloop :: GHC.Prim.Int#
                                                   -> GHC.Prim.State# GHC.Prim.RealWorld
                                                   -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                                         Data.Vector.Unboxed.Base.Vector
                                                           GHC.Types.Double #)
                                           <join 2> {- Arity: 2, Strictness: <S,U><S,U>,
                                                       Inline: [0] -}
                                         = \ (ww3 :: GHC.Prim.Int#)
                                             (w :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                                           case GHC.Prim.==# ww3 ww1 of lwild2 {
                                             DEFAULT
                                             -> case GHC.Prim.>=# ww3 0# of lwild3 {
                                                  DEFAULT -> exit ww3 Statistics.Matrix.diag4
                                                  1#
                                                  -> case GHC.Prim.<# ww3 ww1 of lwild4 {
                                                       DEFAULT -> exit1 ww3 Statistics.Matrix.diag4
                                                       1#
                                                       -> case GHC.Prim.indexDoubleArray#
                                                                 ww2
                                                                 (GHC.Prim.+#
                                                                    ww
                                                                    ww3) of wild1 { DEFAULT ->
                                                          case GHC.Prim.writeDoubleArray#
                                                                 @ (Control.Monad.Primitive.PrimState
                                                                      (GHC.ST.ST
                                                                         GHC.Prim.RealWorld))
                                                                 ipv1
                                                                 (GHC.Prim.+#
                                                                    (GHC.Prim.*# ww3 ww1)
                                                                    ww3)
                                                                 wild1
                                                                 w `cast`
                                                                 (GHC.Prim.State#
                                                                    (Sym (Control.Monad.Primitive.D:R:PrimStateST[0]
                                                                              <GHC.Prim.RealWorld>_N)))_R of s'# { DEFAULT ->
                                                          $wloop
                                                            (GHC.Prim.+# ww3 1#)
                                                            s'#
                                                              `cast`
                                                            (GHC.Prim.State#
                                                               (Control.Monad.Primitive.D:R:PrimStateST[0]
                                                                    <GHC.Prim.RealWorld>_N))_R } } } }
                                             1# -> exit2 w }
                                       } in
                                       $wloop 0# ds9 } }
                                    1#
                                    -> case Statistics.Matrix.diag3 @ GHC.Prim.RealWorld x
                                       ret_ty (# GHC.Prim.State# GHC.Prim.RealWorld,
                                                 Data.Vector.Unboxed.Base.Vector GHC.Types.Double #)
                                       of {} }
                               1#
                               -> case Statistics.Matrix.diag2 @ GHC.Prim.RealWorld x
                                  ret_ty (# GHC.Prim.State# GHC.Prim.RealWorld,
                                            Data.Vector.Unboxed.Base.Vector GHC.Types.Double #)
                                  of {} }
                         } in
                         case GHC.Prim.<=# 0# y1 of lwild {
                           DEFAULT -> $j 0# Statistics.Matrix.diag1
                           1# -> $j y1 (GHC.Types.I# y1) }) of ds1 { (#,#) ipv1 ipv2 ->
                 case ipv2
                        `cast`
                      (Data.Vector.Unboxed.Base.D:R:VectorDouble0[0] ; Data.Vector.Unboxed.Base.N:R:VectorDouble[0]) of nt { Data.Vector.Primitive.Vector ipv ipv4 ipv5 ->
                 (# ww1, ww1,
                    nt
                      `cast`
                    (Sym (Data.Vector.Unboxed.Base.N:R:VectorDouble[0]) ; Sym (Data.Vector.Unboxed.Base.D:R:VectorDouble0[0])) #) } }) -}
caba8fc382a4adcd7b69f59ac8fe9ea0
  $wfoldlM_loop ::
    GHC.Types.SPEC
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Prim.MutableByteArray# GHC.Prim.RealWorld
    -> GHC.Prim.Int#
    -> [GHC.Types.Double]
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          Data.Vector.Unboxed.Base.Vector GHC.Types.Double #)
  {- Arity: 7, Strictness: <S,1*U><L,U><L,U><S,U><L,U><S,1*U><S,U>,
     Inline: [0] -}
3d2bf90ec4fe63d2e0ada3f63407641f
  $wfoldlM_loop1 ::
    GHC.Types.SPEC
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Prim.MutableByteArray# GHC.Prim.RealWorld
    -> GHC.Prim.Int#
    -> [GHC.Types.Double]
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          Data.Vector.Unboxed.Base.Vector GHC.Types.Double #)
  {- Arity: 7, Strictness: <S,1*U><L,U><L,U><S,U><L,U><S,1*U><S,U>,
     Inline: [0] -}
7279fdc51a22b0af2838602ae1415a8c
  $wfromRows ::
    [Statistics.Matrix.Types.Vector]
    -> (# GHC.Prim.Int#, GHC.Prim.Int#,
          Statistics.Matrix.Types.Vector #)
  {- Arity: 1, Strictness: <S,1*U>, Inline: [0],
     Unfolding: (\ (w :: [Statistics.Matrix.Types.Vector]) ->
                 case w of wild {
                   []
                   -> case Statistics.Matrix.fromRows8
                      ret_ty (# GHC.Prim.Int#, GHC.Prim.Int#,
                                Statistics.Matrix.Types.Vector #)
                      of {}
                   : ipv ipv1
                   -> case GHC.Base.map
                             @ (Data.Vector.Unboxed.Base.Vector GHC.Types.Double)
                             @ GHC.Types.Int
                             Statistics.Matrix.fromRows7
                               `cast`
                             (<Data.Vector.Unboxed.Base.Vector GHC.Types.Double>_R
                              ->_R Data.Vector.Fusion.Util.N:Id[0] <GHC.Types.Int>_R)
                             wild of wild1 {
                        []
                        -> case Statistics.Matrix.fromRows6
                           ret_ty (# GHC.Prim.Int#, GHC.Prim.Int#,
                                     Statistics.Matrix.Types.Vector #)
                           of {}
                        : nCol ns
                        -> let {
                             $j :: (# GHC.Prim.Int#, GHC.Prim.Int#,
                                      Statistics.Matrix.Types.Vector #)
                               <join 0>
                             = case nCol of wild2 { GHC.Types.I# x ->
                               case x of wild3 {
                                 DEFAULT
                                 -> case GHC.List.$wlenAcc
                                           @ (Data.Vector.Unboxed.Base.Vector GHC.Types.Double)
                                           wild
                                           0# of ww2 { DEFAULT ->
                                    case GHC.Magic.runRW#
                                           @ ('GHC.Types.TupleRep
                                                '['GHC.Types.TupleRep '[], 'GHC.Types.LiftedRep])
                                           @ (# GHC.Prim.State# GHC.Prim.RealWorld,
                                                Data.Vector.Unboxed.Base.Vector GHC.Types.Double #)
                                           (\ (s1 :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                                            let {
                                              $j1 :: GHC.Prim.Int#
                                                     -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                                           Data.Vector.Unboxed.Base.Vector
                                                             GHC.Types.Double #)
                                                <join 1> {- Arity: 1, Strictness: <S,U> -}
                                              = \ (x1 :: GHC.Prim.Int#)[OneShot] ->
                                                case GHC.Prim.<# x1 0# of lwild {
                                                  DEFAULT
                                                  -> case GHC.Prim.>#
                                                            x1
                                                            1152921504606846975# of lwild1 {
                                                       DEFAULT
                                                       -> case GHC.Prim.newByteArray#
                                                                 @ (Control.Monad.Primitive.PrimState
                                                                      (GHC.ST.ST
                                                                         GHC.Prim.RealWorld))
                                                                 (GHC.Prim.*# x1 8#)
                                                                 s1
                                                                   `cast`
                                                                 (GHC.Prim.State#
                                                                    (Sym (Control.Monad.Primitive.D:R:PrimStateST[0]
                                                                              <GHC.Prim.RealWorld>_N)))_R of ds1 { (#,#) ipv2 ipv3 ->
                                                          let {
                                                            exit :: GHC.Prim.Int#
                                                                    -> GHC.Prim.State#
                                                                         GHC.Prim.RealWorld
                                                                    -> (# GHC.Prim.State#
                                                                            GHC.Prim.RealWorld,
                                                                          Data.Vector.Unboxed.Base.Vector
                                                                            GHC.Types.Double #)
                                                              <join 2> {- Arity: 2,
                                                                          Strictness: <L,U><S,U> -}
                                                            = \ (ww :: GHC.Prim.Int#)[OneShot]
                                                                (w1 :: GHC.Prim.State#
                                                                         GHC.Prim.RealWorld)[OneShot] ->
                                                              case GHC.Prim.unsafeFreezeByteArray#
                                                                     @ (Control.Monad.Primitive.PrimState
                                                                          (GHC.ST.ST
                                                                             GHC.Prim.RealWorld))
                                                                     ipv3
                                                                     w1
                                                                       `cast`
                                                                     (GHC.Prim.State#
                                                                        (Sym (Control.Monad.Primitive.D:R:PrimStateST[0]
                                                                                  <GHC.Prim.RealWorld>_N)))_R of ds2 { (#,#) ipv4 ipv5 ->
                                                              (# ipv4
                                                                   `cast`
                                                                 (GHC.Prim.State#
                                                                    (Control.Monad.Primitive.D:R:PrimStateST[0]
                                                                         <GHC.Prim.RealWorld>_N))_R,
                                                                 (Data.Vector.Primitive.Vector
                                                                    @ GHC.Types.Double
                                                                    0#
                                                                    ww
                                                                    ipv5)
                                                                   `cast`
                                                                 (Sym (Data.Vector.Unboxed.Base.N:R:VectorDouble[0]) ; Sym (Data.Vector.Unboxed.Base.D:R:VectorDouble0[0])) #) }
                                                          } in
                                                          letrec {
                                                            $wfoldlM'_loop :: GHC.Types.SPEC
                                                                              -> GHC.Prim.Int#
                                                                              -> [Data.Vector.Unboxed.Base.Vector
                                                                                    GHC.Types.Double]
                                                                              -> GHC.Prim.State#
                                                                                   GHC.Prim.RealWorld
                                                                              -> (# GHC.Prim.State#
                                                                                      GHC.Prim.RealWorld,
                                                                                    Data.Vector.Unboxed.Base.Vector
                                                                                      GHC.Types.Double #)
                                                              <join 4> {- Arity: 4,
                                                                          Strictness: <S,1*U><S,U><S,1*U><S,U>,
                                                                          Inline: [0] -}
                                                            = \ (w1 :: GHC.Types.SPEC)
                                                                (ww :: GHC.Prim.Int#)
                                                                (w2 :: [Data.Vector.Unboxed.Base.Vector
                                                                          GHC.Types.Double])
                                                                (w3 :: GHC.Prim.State#
                                                                         GHC.Prim.RealWorld) ->
                                                              case w1 of ds5 { DEFAULT ->
                                                              case w2 of wild4 {
                                                                [] -> exit ww w3
                                                                : v1 vs
                                                                -> case v1
                                                                          `cast`
                                                                        (Data.Vector.Unboxed.Base.D:R:VectorDouble0[0] ; Data.Vector.Unboxed.Base.N:R:VectorDouble[0]) of wild5 { Data.Vector.Primitive.Vector dt dt1 dt2 ->
                                                                   case GHC.Prim.copyByteArray#
                                                                          @ (Control.Monad.Primitive.PrimState
                                                                               (GHC.ST.ST
                                                                                  GHC.Prim.RealWorld))
                                                                          dt2
                                                                          (GHC.Prim.*# dt 8#)
                                                                          ipv3
                                                                          (GHC.Prim.*# ww 8#)
                                                                          (GHC.Prim.*# dt1 8#)
                                                                          w3
                                                                            `cast`
                                                                          (GHC.Prim.State#
                                                                             (Sym (Control.Monad.Primitive.D:R:PrimStateST[0]
                                                                                       <GHC.Prim.RealWorld>_N)))_R of s'# { DEFAULT ->
                                                                   $wfoldlM'_loop
                                                                     GHC.Types.SPEC
                                                                     (GHC.Prim.+# ww dt1)
                                                                     vs
                                                                     s'#
                                                                       `cast`
                                                                     (GHC.Prim.State#
                                                                        (Control.Monad.Primitive.D:R:PrimStateST[0]
                                                                             <GHC.Prim.RealWorld>_N))_R } } } }
                                                          } in
                                                          $wfoldlM'_loop
                                                            GHC.Types.SPEC
                                                            0#
                                                            wild
                                                            ipv2
                                                              `cast`
                                                            (GHC.Prim.State#
                                                               (Control.Monad.Primitive.D:R:PrimStateST[0]
                                                                    <GHC.Prim.RealWorld>_N))_R }
                                                       1#
                                                       -> case Statistics.Matrix.fromRows5 x1
                                                          ret_ty (# GHC.Prim.State#
                                                                      GHC.Prim.RealWorld,
                                                                    Data.Vector.Unboxed.Base.Vector
                                                                      GHC.Types.Double #)
                                                          of {} }
                                                  1#
                                                  -> case Statistics.Matrix.fromRows4 x1
                                                     ret_ty (# GHC.Prim.State# GHC.Prim.RealWorld,
                                                               Data.Vector.Unboxed.Base.Vector
                                                                 GHC.Types.Double #)
                                                     of {} }
                                            } in
                                            letrec {
                                              $wgo1 :: [Data.Vector.Unboxed.Base.Vector
                                                          GHC.Types.Double]
                                                       -> GHC.Prim.Int#
                                                       -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                                             Data.Vector.Unboxed.Base.Vector
                                                               GHC.Types.Double #)
                                                <join 2> {- Arity: 2, Strictness: <S,1*U><S,U>,
                                                            Inline: [0] -}
                                              = \ (w1 :: [Data.Vector.Unboxed.Base.Vector
                                                            GHC.Types.Double])
                                                  (ww :: GHC.Prim.Int#) ->
                                                case w1 of wild4 {
                                                  [] -> $j1 ww
                                                  : y ys
                                                  -> case y `cast`
                                                          (Data.Vector.Unboxed.Base.D:R:VectorDouble0[0] ; Data.Vector.Unboxed.Base.N:R:VectorDouble[0]) of wild5 { Data.Vector.Primitive.Vector dt dt1 dt2 ->
                                                     $wgo1 ys (GHC.Prim.+# ww dt1) } }
                                            } in
                                            $wgo1 wild 0#) of ds1 { (#,#) ipv2 ipv3 ->
                                    case ipv3
                                           `cast`
                                         (Data.Vector.Unboxed.Base.D:R:VectorDouble0[0] ; Data.Vector.Unboxed.Base.N:R:VectorDouble[0]) of nt { Data.Vector.Primitive.Vector ipv4 ipv5 ipv6 ->
                                    case GHC.Prim./=# (GHC.Prim.*# ww2 wild3) ipv5 of lwild {
                                      DEFAULT
                                      -> (# ww2, wild3,
                                            nt
                                              `cast`
                                            (Sym (Data.Vector.Unboxed.Base.N:R:VectorDouble[0]) ; Sym (Data.Vector.Unboxed.Base.D:R:VectorDouble0[0])) #)
                                      1#
                                      -> case Statistics.Matrix.fromRows3
                                         ret_ty (# GHC.Prim.Int#, GHC.Prim.Int#,
                                                   Statistics.Matrix.Types.Vector #)
                                         of {} } } } }
                                 0#
                                 -> case Statistics.Matrix.fromRows2
                                    ret_ty (# GHC.Prim.Int#, GHC.Prim.Int#,
                                              Statistics.Matrix.Types.Vector #)
                                    of {} } }
                           } in
                           letrec {
                             go :: [GHC.Types.Int]
                                   -> (# GHC.Prim.Int#, GHC.Prim.Int#,
                                         Statistics.Matrix.Types.Vector #)
                               <join 1> {- Arity: 1, Strictness: <S,1*U> -}
                             = \ (ds :: [GHC.Types.Int]) ->
                               case ds of wild2 {
                                 [] -> $j
                                 : y ys
                                 -> case y of wild3 { GHC.Types.I# x ->
                                    case nCol of wild4 { GHC.Types.I# y1 ->
                                    case GHC.Prim./=# x y1 of lwild {
                                      DEFAULT -> go ys
                                      1#
                                      -> case Statistics.Matrix.fromRows1
                                         ret_ty (# GHC.Prim.Int#, GHC.Prim.Int#,
                                                   Statistics.Matrix.Types.Vector #)
                                         of {} } } } }
                           } in
                           go ns } }) -}
a325a7b9942b62d080b4dfe682fca0fa
  $wgenerate ::
    GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> (GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Double)
    -> (# GHC.Prim.Int#, GHC.Prim.Int#,
          Statistics.Matrix.Types.Vector #)
  {- Arity: 3, Strictness: <S,U><S,U><L,C(C1(U(U)))>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#)
                   (ww1 :: GHC.Prim.Int#)
                   (w :: GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Double) ->
                 case GHC.Magic.runRW#
                        @ ('GHC.Types.TupleRep
                             '['GHC.Types.TupleRep '[], 'GHC.Types.LiftedRep])
                        @ (# GHC.Prim.State# GHC.Prim.RealWorld,
                             Data.Vector.Unboxed.Base.Vector GHC.Types.Double #)
                        (\ (s1 :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                         let {
                           n :: GHC.Prim.Int# = GHC.Prim.*# ww ww1
                         } in
                         let {
                           $w$j :: GHC.Prim.Int#
                                   -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                         Data.Vector.Unboxed.Base.Vector GHC.Types.Double #)
                             <join 1> {- Arity: 1, Strictness: <S,U>, Inline: [0] -}
                           = \ (w1 :: GHC.Prim.Int#)[OneShot] ->
                             case GHC.Prim.<# w1 0# of lwild {
                               DEFAULT
                               -> case GHC.Prim.># w1 1152921504606846975# of lwild1 {
                                    DEFAULT
                                    -> case GHC.Prim.newByteArray#
                                              @ (Control.Monad.Primitive.PrimState
                                                   (GHC.ST.ST GHC.Prim.RealWorld))
                                              (GHC.Prim.*# w1 8#)
                                              s1
                                                `cast`
                                              (GHC.Prim.State#
                                                 (Sym (Control.Monad.Primitive.D:R:PrimStateST[0]
                                                           <GHC.Prim.RealWorld>_N)))_R of ds1 { (#,#) ipv ipv1 ->
                                       let {
                                         exit :: GHC.Prim.Int#
                                                 -> GHC.Prim.State# GHC.Prim.RealWorld
                                                 -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                                       Data.Vector.Unboxed.Base.Vector
                                                         GHC.Types.Double #)
                                           <join 2> {- Arity: 2, Strictness: <L,U><S,U> -}
                                         = \ (ww2 :: GHC.Prim.Int#)[OneShot]
                                             (w2 :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                                           case GHC.Prim.unsafeFreezeByteArray#
                                                  @ (Control.Monad.Primitive.PrimState
                                                       (GHC.ST.ST GHC.Prim.RealWorld))
                                                  ipv1
                                                  w2
                                                    `cast`
                                                  (GHC.Prim.State#
                                                     (Sym (Control.Monad.Primitive.D:R:PrimStateST[0]
                                                               <GHC.Prim.RealWorld>_N)))_R of ds2 { (#,#) ipv2 ipv3 ->
                                           (# ipv2
                                                `cast`
                                              (GHC.Prim.State#
                                                 (Control.Monad.Primitive.D:R:PrimStateST[0]
                                                      <GHC.Prim.RealWorld>_N))_R,
                                              (Data.Vector.Primitive.Vector
                                                 @ GHC.Types.Double
                                                 0#
                                                 ww2
                                                 ipv3)
                                                `cast`
                                              (Sym (Data.Vector.Unboxed.Base.N:R:VectorDouble[0]) ; Sym (Data.Vector.Unboxed.Base.D:R:VectorDouble0[0])) #) }
                                       } in
                                       letrec {
                                         $wfoldlM'_loop :: GHC.Types.SPEC
                                                           -> GHC.Prim.Int#
                                                           -> GHC.Prim.Int#
                                                           -> GHC.Prim.State# GHC.Prim.RealWorld
                                                           -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                                                 Data.Vector.Unboxed.Base.Vector
                                                                   GHC.Types.Double #)
                                           <join 4> {- Arity: 4, Strictness: <S,1*U><S,U><S,U><S,U>,
                                                       Inline: [0] -}
                                         = \ (w2 :: GHC.Types.SPEC)
                                             (ww2 :: GHC.Prim.Int#)
                                             (ww3 :: GHC.Prim.Int#)
                                             (w3 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                                           case w2 of ds5 { DEFAULT ->
                                           case GHC.Prim.<# ww3 n of lwild2 {
                                             DEFAULT -> exit ww2 w3
                                             1#
                                             -> let {
                                                  ds :: (GHC.Types.Int, GHC.Types.Int)
                                                  = case ww1 of wild {
                                                      DEFAULT
                                                      -> case GHC.Prim.quotRemInt#
                                                                ww3
                                                                wild of ds2 { (#,#) ipv2 ipv3 ->
                                                         (GHC.Types.I# ipv2, GHC.Types.I# ipv3) }
                                                      -1#
                                                      -> case ww3 of wild1 {
                                                           DEFAULT
                                                           -> case GHC.Prim.quotRemInt#
                                                                     wild1
                                                                     -1# of ds2 { (#,#) ipv2 ipv3 ->
                                                              (GHC.Types.I# ipv2,
                                                               GHC.Types.I# ipv3) }
                                                           -9223372036854775808#
                                                           -> Statistics.Matrix.generate1 }
                                                      0#
                                                      -> case GHC.Real.divZeroError
                                                         ret_ty (GHC.Types.Int, GHC.Types.Int)
                                                         of {} }
                                                } in
                                                case w (case ds of wild { (,) r c -> r })
                                                       (case ds of wild { (,) r c ->
                                                        c }) of wild2 { GHC.Types.D# x# ->
                                                case GHC.Prim.writeDoubleArray#
                                                       @ (Control.Monad.Primitive.PrimState
                                                            (GHC.ST.ST GHC.Prim.RealWorld))
                                                       ipv1
                                                       ww2
                                                       x#
                                                       w3
                                                         `cast`
                                                       (GHC.Prim.State#
                                                          (Sym (Control.Monad.Primitive.D:R:PrimStateST[0]
                                                                    <GHC.Prim.RealWorld>_N)))_R of s'# { DEFAULT ->
                                                $wfoldlM'_loop
                                                  GHC.Types.SPEC
                                                  (GHC.Prim.+# ww2 1#)
                                                  (GHC.Prim.+# ww3 1#)
                                                  s'#
                                                    `cast`
                                                  (GHC.Prim.State#
                                                     (Control.Monad.Primitive.D:R:PrimStateST[0]
                                                          <GHC.Prim.RealWorld>_N))_R } } } }
                                       } in
                                       $wfoldlM'_loop
                                         GHC.Types.SPEC
                                         0#
                                         0#
                                         ipv
                                           `cast`
                                         (GHC.Prim.State#
                                            (Control.Monad.Primitive.D:R:PrimStateST[0]
                                                 <GHC.Prim.RealWorld>_N))_R }
                                    1#
                                    -> case Statistics.Matrix.fromRows5 w1
                                       ret_ty (# GHC.Prim.State# GHC.Prim.RealWorld,
                                                 Data.Vector.Unboxed.Base.Vector GHC.Types.Double #)
                                       of {} }
                               1#
                               -> case Statistics.Matrix.fromRows4 w1
                                  ret_ty (# GHC.Prim.State# GHC.Prim.RealWorld,
                                            Data.Vector.Unboxed.Base.Vector GHC.Types.Double #)
                                  of {} }
                         } in
                         case GHC.Prim.<=# n 0# of lwild {
                           DEFAULT -> $w$j n 1# -> $w$j 0# }) of ds1 { (#,#) ipv1 ipv2 ->
                 case ipv2
                        `cast`
                      (Data.Vector.Unboxed.Base.D:R:VectorDouble0[0] ; Data.Vector.Unboxed.Base.N:R:VectorDouble[0]) of nt { Data.Vector.Primitive.Vector ipv ipv4 ipv5 ->
                 (# ww, ww1,
                    nt
                      `cast`
                    (Sym (Data.Vector.Unboxed.Base.N:R:VectorDouble[0]) ; Sym (Data.Vector.Unboxed.Base.D:R:VectorDouble0[0])) #) } }) -}
e90547862310463659b0877cf2ba51f0
  $wgenerateSym ::
    GHC.Prim.Int#
    -> (GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Double)
    -> Statistics.Matrix.Types.Matrix
  {- Arity: 2, Strictness: <S,U><L,C(C1(U(U)))>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#)
                   (w :: GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Double) ->
                 case GHC.Magic.runRW#
                        @ ('GHC.Types.TupleRep
                             '['GHC.Types.TupleRep '[], 'GHC.Types.LiftedRep])
                        @ (# GHC.Prim.State# GHC.Prim.RealWorld,
                             Statistics.Matrix.Types.Matrix #)
                        (\ (s1 :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                         case Statistics.Matrix.Mutable.$wunsafeNew
                                @ GHC.Prim.RealWorld
                                ww
                                ww
                                s1 of ds1 { (#,#) ipv ipv1 ->
                         let {
                           exit :: GHC.Prim.State# GHC.Prim.RealWorld
                                   -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                         Statistics.Matrix.Types.Matrix #)
                             <join 1> {- Arity: 1, Strictness: <S,U> -}
                           = \ (w1 :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                             Statistics.Matrix.Mutable.unsafeFreeze1
                               @ GHC.Prim.RealWorld
                               ipv1
                               w1
                         } in
                         letrec {
                           $wloop :: GHC.Prim.Int#
                                     -> GHC.Prim.State# GHC.Prim.RealWorld
                                     -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                           Statistics.Matrix.Types.Matrix #)
                             <join 2> {- Arity: 2, Strictness: <S,U><S,U>, Inline: [0] -}
                           = \ (ww1 :: GHC.Prim.Int#)
                               (w1 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                             case GHC.Prim.==# ww1 ww of lwild {
                               DEFAULT
                               -> case ipv1 of wild { Statistics.Matrix.Types.MMatrix dt dt1 mv ->
                                  case mv
                                         `cast`
                                       (Data.Vector.Unboxed.Base.D:R:MVectorsDouble0[0]
                                            (Sym (Control.Monad.Primitive.D:R:PrimStateST[0]
                                                      <GHC.Prim.RealWorld>_N)) ; Data.Vector.Unboxed.Base.N:R:MVectorsDouble[0]
                                                                                     <Control.Monad.Primitive.PrimState
                                                                                        (GHC.ST.ST
                                                                                           GHC.Prim.RealWorld)>_N) of wild3 { Data.Vector.Primitive.Mutable.MVector dt2 dt3 dt4 ->
                                  let {
                                    wild1 :: GHC.Types.Int = GHC.Types.I# ww1
                                  } in
                                  case w wild1 wild1 of wild4 { GHC.Types.D# x# ->
                                  case GHC.Prim.writeDoubleArray#
                                         @ (Control.Monad.Primitive.PrimState
                                              (GHC.ST.ST GHC.Prim.RealWorld))
                                         dt4
                                         (GHC.Prim.+# dt2 (GHC.Prim.+# (GHC.Prim.*# ww1 dt1) ww1))
                                         x#
                                         w1
                                           `cast`
                                         (GHC.Prim.State#
                                            (Sym (Control.Monad.Primitive.D:R:PrimStateST[0]
                                                      <GHC.Prim.RealWorld>_N)))_R of s'# { DEFAULT ->
                                  let {
                                    exit1 :: GHC.Prim.State# GHC.Prim.RealWorld
                                             -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                                   Statistics.Matrix.Types.Matrix #)
                                      <join 1> {- Arity: 1, Strictness: <S,U> -}
                                    = \ (w2 :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                                      $wloop (GHC.Prim.+# ww1 1#) w2
                                  } in
                                  letrec {
                                    $wloop1 :: GHC.Prim.Int#
                                               -> GHC.Prim.State# GHC.Prim.RealWorld
                                               -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                                     Statistics.Matrix.Types.Matrix #)
                                      <join 2> {- Arity: 2, Strictness: <S,U><S,U>, Inline: [0] -}
                                    = \ (ww2 :: GHC.Prim.Int#)
                                        (w2 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                                      case GHC.Prim.==# ww2 ww of lwild1 {
                                        DEFAULT
                                        -> case w wild1
                                                  (GHC.Types.I# ww2) of wild2 { GHC.Types.D# x#1 ->
                                           case GHC.Prim.writeDoubleArray#
                                                  @ (Control.Monad.Primitive.PrimState
                                                       (GHC.ST.ST GHC.Prim.RealWorld))
                                                  dt4
                                                  (GHC.Prim.+#
                                                     dt2
                                                     (GHC.Prim.+# (GHC.Prim.*# ww1 dt1) ww2))
                                                  x#1
                                                  w2
                                                    `cast`
                                                  (GHC.Prim.State#
                                                     (Sym (Control.Monad.Primitive.D:R:PrimStateST[0]
                                                               <GHC.Prim.RealWorld>_N)))_R of s'#1 { DEFAULT ->
                                           case GHC.Prim.writeDoubleArray#
                                                  @ (Control.Monad.Primitive.PrimState
                                                       (GHC.ST.ST GHC.Prim.RealWorld))
                                                  dt4
                                                  (GHC.Prim.+#
                                                     dt2
                                                     (GHC.Prim.+# (GHC.Prim.*# ww2 dt1) ww1))
                                                  x#1
                                                  s'#1 of s'#2 { DEFAULT ->
                                           $wloop1
                                             (GHC.Prim.+# ww2 1#)
                                             s'#2
                                               `cast`
                                             (GHC.Prim.State#
                                                (Control.Monad.Primitive.D:R:PrimStateST[0]
                                                     <GHC.Prim.RealWorld>_N))_R } } }
                                        1# -> exit1 w2 }
                                  } in
                                  $wloop1
                                    (GHC.Prim.+# ww1 1#)
                                    s'#
                                      `cast`
                                    (GHC.Prim.State#
                                       (Control.Monad.Primitive.D:R:PrimStateST[0]
                                            <GHC.Prim.RealWorld>_N))_R } } } }
                               1# -> exit w1 }
                         } in
                         $wloop 0# ipv }) of ds1 { (#,#) ipv ipv1 ->
                 ipv1 }) -}
8dcb599580b542fa63847c1dbb7ebd7f
  $whasNaN ::
    GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Prim.ByteArray#
    -> Data.Vector.Fusion.Util.Id GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U><S,U><L,U>,
     Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#)
                   (ww1 :: GHC.Prim.Int#)
                   (ww2 :: GHC.Prim.ByteArray#) ->
                 letrec {
                   $wor_loop :: GHC.Types.SPEC
                                -> GHC.Prim.Int# -> Data.Vector.Fusion.Util.Id GHC.Types.Bool
                     <join 2> {- Arity: 2, Strictness: <S,1*U><S,U>, Inline: [0] -}
                   = \ (w :: GHC.Types.SPEC) (ww3 :: GHC.Prim.Int#) ->
                     case w of ds5 { DEFAULT ->
                     case GHC.Prim.>=# ww3 ww1 of lwild {
                       DEFAULT
                       -> case GHC.Prim.indexDoubleArray#
                                 ww2
                                 (GHC.Prim.+# ww ww3) of wild2 { DEFAULT ->
                          case {__pkg_ccall base-4.11.1.0 GHC.Prim.Double#
                                                          -> GHC.Prim.State# GHC.Prim.RealWorld
                                                          -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                                                GHC.Prim.Int# #)}
                                 wild2
                                 GHC.Prim.realWorld# of wild { (#,#) ds2 ds3 ->
                          case ds3 of wild1 {
                            DEFAULT
                            -> GHC.Types.True
                                 `cast`
                               (Sym (Data.Vector.Fusion.Util.N:Id[0] <GHC.Types.Bool>_R))
                            0# -> $wor_loop GHC.Types.SPEC (GHC.Prim.+# ww3 1#) } } }
                       1#
                       -> GHC.Types.False
                            `cast`
                          (Sym (Data.Vector.Fusion.Util.N:Id[0] <GHC.Types.Bool>_R)) } }
                 } in
                 $wor_loop GHC.Types.SPEC 0#) -}
1d81e1c78c30fa6c8aacf3712f716f21
  $wident ::
    GHC.Prim.Int#
    -> (# GHC.Prim.Int#, GHC.Prim.Int#,
          Statistics.Matrix.Types.Vector #)
  {- Arity: 1, Strictness: <S,U>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#) ->
                 case GHC.Magic.runRW#
                        @ ('GHC.Types.TupleRep
                             '['GHC.Types.TupleRep '[], 'GHC.Types.LiftedRep])
                        @ (# GHC.Prim.State# GHC.Prim.RealWorld,
                             Data.Vector.Unboxed.Base.Vector GHC.Types.Double #)
                        (\ (s1 :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                         let {
                           $j :: GHC.Prim.Int#
                                 -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                       Data.Vector.Unboxed.Base.Vector GHC.Types.Double #)
                             <join 1> {- Arity: 1, Strictness: <S,U> -}
                           = \ (x :: GHC.Prim.Int#)[OneShot] ->
                             case GHC.Prim.<# x 0# of lwild {
                               DEFAULT
                               -> case GHC.Prim.># x 1152921504606846975# of lwild1 {
                                    DEFAULT
                                    -> case GHC.Prim.newByteArray#
                                              @ (Control.Monad.Primitive.PrimState
                                                   (GHC.ST.ST GHC.Prim.RealWorld))
                                              (GHC.Prim.*# x 8#)
                                              s1
                                                `cast`
                                              (GHC.Prim.State#
                                                 (Sym (Control.Monad.Primitive.D:R:PrimStateST[0]
                                                           <GHC.Prim.RealWorld>_N)))_R of ds1 { (#,#) ipv ipv1 ->
                                       let {
                                         exit :: GHC.Prim.Int#
                                                 -> GHC.Prim.State# GHC.Prim.RealWorld
                                                 -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                                       Data.Vector.Unboxed.Base.Vector
                                                         GHC.Types.Double #)
                                           <join 2> {- Arity: 2, Strictness: <L,U><S,U> -}
                                         = \ (ww1 :: GHC.Prim.Int#)[OneShot]
                                             (w :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                                           case GHC.Prim.unsafeFreezeByteArray#
                                                  @ (Control.Monad.Primitive.PrimState
                                                       (GHC.ST.ST GHC.Prim.RealWorld))
                                                  ipv1
                                                  w `cast`
                                                  (GHC.Prim.State#
                                                     (Sym (Control.Monad.Primitive.D:R:PrimStateST[0]
                                                               <GHC.Prim.RealWorld>_N)))_R of ds2 { (#,#) ipv2 ipv3 ->
                                           (# ipv2
                                                `cast`
                                              (GHC.Prim.State#
                                                 (Control.Monad.Primitive.D:R:PrimStateST[0]
                                                      <GHC.Prim.RealWorld>_N))_R,
                                              (Data.Vector.Primitive.Vector
                                                 @ GHC.Types.Double
                                                 0#
                                                 ww1
                                                 ipv3)
                                                `cast`
                                              (Sym (Data.Vector.Unboxed.Base.N:R:VectorDouble[0]) ; Sym (Data.Vector.Unboxed.Base.D:R:VectorDouble0[0])) #) }
                                       } in
                                       letrec {
                                         $wfoldlM'_loop :: GHC.Types.SPEC
                                                           -> GHC.Prim.Int#
                                                           -> GHC.Types.Bool
                                                           -> GHC.Prim.State# GHC.Prim.RealWorld
                                                           -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                                                 Data.Vector.Unboxed.Base.Vector
                                                                   GHC.Types.Double #)
                                           <join 4> {- Arity: 4,
                                                       Strictness: <S,1*U><S,U><S,1*U><S,U>,
                                                       Inline: [0] -}
                                         = \ (w :: GHC.Types.SPEC)
                                             (ww1 :: GHC.Prim.Int#)
                                             (w1 :: GHC.Types.Bool)
                                             (w2 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                                           case w of ds5 { DEFAULT ->
                                           case w1 of wild {
                                             GHC.Types.False -> exit ww1 w2
                                             GHC.Types.True
                                             -> case {__pkg_ccall primitive-0.6.3.0 forall s.
                                                                                    GHC.Prim.MutableByteArray#
                                                                                      s
                                                                                    -> GHC.Prim.Int#
                                                                                    -> GHC.Prim.Word#
                                                                                    -> GHC.Prim.Double#
                                                                                    -> GHC.Prim.State#
                                                                                         GHC.Prim.RealWorld
                                                                                    -> (# GHC.Prim.State#
                                                                                            GHC.Prim.RealWorld #)}
                                                       @ (Control.Monad.Primitive.PrimState
                                                            (GHC.ST.ST GHC.Prim.RealWorld))
                                                       ipv1
                                                       ww1
                                                       (GHC.Prim.int2Word# x)
                                                       1.0##
                                                       w2 of wild2 { Unit# ds9 ->
                                                $wfoldlM'_loop
                                                  GHC.Types.SPEC
                                                  (GHC.Prim.+# ww1 x)
                                                  GHC.Types.False
                                                  ds9 } } }
                                       } in
                                       $wfoldlM'_loop
                                         GHC.Types.SPEC
                                         0#
                                         GHC.Types.True
                                         ipv
                                           `cast`
                                         (GHC.Prim.State#
                                            (Control.Monad.Primitive.D:R:PrimStateST[0]
                                                 <GHC.Prim.RealWorld>_N))_R }
                                    1#
                                    -> case Statistics.Matrix.fromRows5 x
                                       ret_ty (# GHC.Prim.State# GHC.Prim.RealWorld,
                                                 Data.Vector.Unboxed.Base.Vector GHC.Types.Double #)
                                       of {} }
                               1#
                               -> case Statistics.Matrix.fromRows4 x
                                  ret_ty (# GHC.Prim.State# GHC.Prim.RealWorld,
                                            Data.Vector.Unboxed.Base.Vector GHC.Types.Double #)
                                  of {} }
                         } in
                         case GHC.Prim.<=# ww 0# of lwild {
                           DEFAULT -> $j ww 1# -> $j 0# }) of ds1 { (#,#) ipv1 ipv2 ->
                 case ipv2
                        `cast`
                      (Data.Vector.Unboxed.Base.D:R:VectorDouble0[0] ; Data.Vector.Unboxed.Base.N:R:VectorDouble[0]) of ww1 { Data.Vector.Primitive.Vector ww2 ww3 ww4 ->
                 Statistics.Matrix.$wdiag ww2 ww3 ww4 } }) -}
467595fc47fb7ea0f147eae3d2ae82bb
  $wlvl ::
    GHC.Prim.Int# -> GHC.Prim.Int# -> Statistics.Matrix.Types.Vector
  {- Arity: 2, Strictness: <B,U><B,U>x, Inline: [0] -}
03d79e1193be486919dc8343f7a05cd4
  $wmap ::
    (GHC.Types.Double -> GHC.Types.Double)
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Prim.ByteArray#
    -> (# GHC.Prim.Int#, GHC.Prim.Int#,
          Statistics.Matrix.Types.Vector #)
  {- Arity: 6, Strictness: <L,C(U(U))><L,U><L,U><L,U><S,U><L,U>,
     Inline: [0],
     Unfolding: (\ (w :: GHC.Types.Double -> GHC.Types.Double)
                   (ww :: GHC.Prim.Int#)
                   (ww1 :: GHC.Prim.Int#)
                   (ww2 :: GHC.Prim.Int#)
                   (ww3 :: GHC.Prim.Int#)
                   (ww4 :: GHC.Prim.ByteArray#) ->
                 case GHC.Magic.runRW#
                        @ ('GHC.Types.TupleRep
                             '['GHC.Types.TupleRep '[], 'GHC.Types.LiftedRep])
                        @ (# GHC.Prim.State# GHC.Prim.RealWorld,
                             Data.Vector.Unboxed.Base.Vector GHC.Types.Double #)
                        (\ (s1 :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                         case GHC.Prim.<# ww3 0# of lwild {
                           DEFAULT
                           -> case GHC.Prim.># ww3 1152921504606846975# of lwild1 {
                                DEFAULT
                                -> case GHC.Prim.newByteArray#
                                          @ (Control.Monad.Primitive.PrimState
                                               (GHC.ST.ST GHC.Prim.RealWorld))
                                          (GHC.Prim.*# ww3 8#)
                                          s1
                                            `cast`
                                          (GHC.Prim.State#
                                             (Sym (Control.Monad.Primitive.D:R:PrimStateST[0]
                                                       <GHC.Prim.RealWorld>_N)))_R of ds1 { (#,#) ipv ipv1 ->
                                   let {
                                     exit :: GHC.Prim.Int#
                                             -> GHC.Prim.State# GHC.Prim.RealWorld
                                             -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                                   Data.Vector.Unboxed.Base.Vector
                                                     GHC.Types.Double #)
                                       <join 2> {- Arity: 2, Strictness: <L,U><S,U> -}
                                     = \ (ww5 :: GHC.Prim.Int#)[OneShot]
                                         (w1 :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                                       case GHC.Prim.unsafeFreezeByteArray#
                                              @ (Control.Monad.Primitive.PrimState
                                                   (GHC.ST.ST GHC.Prim.RealWorld))
                                              ipv1
                                              w1
                                                `cast`
                                              (GHC.Prim.State#
                                                 (Sym (Control.Monad.Primitive.D:R:PrimStateST[0]
                                                           <GHC.Prim.RealWorld>_N)))_R of ds2 { (#,#) ipv2 ipv3 ->
                                       (# ipv2
                                            `cast`
                                          (GHC.Prim.State#
                                             (Control.Monad.Primitive.D:R:PrimStateST[0]
                                                  <GHC.Prim.RealWorld>_N))_R,
                                          (Data.Vector.Primitive.Vector
                                             @ GHC.Types.Double
                                             0#
                                             ww5
                                             ipv3)
                                            `cast`
                                          (Sym (Data.Vector.Unboxed.Base.N:R:VectorDouble[0]) ; Sym (Data.Vector.Unboxed.Base.D:R:VectorDouble0[0])) #) }
                                   } in
                                   letrec {
                                     $wfoldlM'_loop :: GHC.Types.SPEC
                                                       -> GHC.Prim.Int#
                                                       -> GHC.Prim.Int#
                                                       -> GHC.Prim.State# GHC.Prim.RealWorld
                                                       -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                                             Data.Vector.Unboxed.Base.Vector
                                                               GHC.Types.Double #)
                                       <join 4> {- Arity: 4, Strictness: <S,1*U><S,U><S,U><S,U>,
                                                   Inline: [0] -}
                                     = \ (w1 :: GHC.Types.SPEC)
                                         (ww5 :: GHC.Prim.Int#)
                                         (ww6 :: GHC.Prim.Int#)
                                         (w2 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                                       case w1 of ds5 { DEFAULT ->
                                       case GHC.Prim.>=# ww6 ww3 of lwild2 {
                                         DEFAULT
                                         -> case GHC.Prim.indexDoubleArray#
                                                   ww4
                                                   (GHC.Prim.+# ww2 ww6) of wild2 { DEFAULT ->
                                            case w (GHC.Types.D#
                                                      wild2) of wild1 { GHC.Types.D# x# ->
                                            case GHC.Prim.writeDoubleArray#
                                                   @ (Control.Monad.Primitive.PrimState
                                                        (GHC.ST.ST GHC.Prim.RealWorld))
                                                   ipv1
                                                   ww5
                                                   x#
                                                   w2
                                                     `cast`
                                                   (GHC.Prim.State#
                                                      (Sym (Control.Monad.Primitive.D:R:PrimStateST[0]
                                                                <GHC.Prim.RealWorld>_N)))_R of s'# { DEFAULT ->
                                            $wfoldlM'_loop
                                              GHC.Types.SPEC
                                              (GHC.Prim.+# ww5 1#)
                                              (GHC.Prim.+# ww6 1#)
                                              s'#
                                                `cast`
                                              (GHC.Prim.State#
                                                 (Control.Monad.Primitive.D:R:PrimStateST[0]
                                                      <GHC.Prim.RealWorld>_N))_R } } }
                                         1# -> exit ww5 w2 } }
                                   } in
                                   $wfoldlM'_loop
                                     GHC.Types.SPEC
                                     0#
                                     0#
                                     ipv
                                       `cast`
                                     (GHC.Prim.State#
                                        (Control.Monad.Primitive.D:R:PrimStateST[0]
                                             <GHC.Prim.RealWorld>_N))_R }
                                1#
                                -> case Statistics.Matrix.fromRows5 ww3
                                   ret_ty (# GHC.Prim.State# GHC.Prim.RealWorld,
                                             Data.Vector.Unboxed.Base.Vector GHC.Types.Double #)
                                   of {} }
                           1#
                           -> case Statistics.Matrix.fromRows4 ww3
                              ret_ty (# GHC.Prim.State# GHC.Prim.RealWorld,
                                        Data.Vector.Unboxed.Base.Vector GHC.Types.Double #)
                              of {} }) of ds1 { (#,#) ipv1 ipv2 ->
                 case ipv2
                        `cast`
                      (Data.Vector.Unboxed.Base.D:R:VectorDouble0[0] ; Data.Vector.Unboxed.Base.N:R:VectorDouble[0]) of nt { Data.Vector.Primitive.Vector ipv ipv4 ipv5 ->
                 (# ww, ww1,
                    nt
                      `cast`
                    (Sym (Data.Vector.Unboxed.Base.N:R:VectorDouble[0]) ; Sym (Data.Vector.Unboxed.Base.D:R:VectorDouble0[0])) #) } }) -}
77aeb9924d07cdc83775015f08db0706
  $wmultiply ::
    GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Prim.ByteArray#
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Prim.ByteArray#
    -> (# GHC.Prim.Int#, GHC.Prim.Int#,
          Statistics.Matrix.Types.Vector #)
  {- Arity: 10,
     Strictness: <S,U><L,U><L,U><L,U><L,U><L,U><S,U><L,U><L,U><L,U>,
     Inline: [0] -}
8a7d34582752337c21d7a225a998f13d
  $wmultiplyV ::
    GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Prim.ByteArray#
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Prim.ByteArray#
    -> Data.Vector.Unboxed.Base.Vector GHC.Types.Double
  {- Arity: 8, Strictness: <S,U><S,U><L,U><L,U><L,U><L,U><S,U><L,U>,
     Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#)
                   (ww1 :: GHC.Prim.Int#)
                   (ww2 :: GHC.Prim.Int#)
                   (ww3 :: GHC.Prim.Int#)
                   (ww4 :: GHC.Prim.ByteArray#)
                   (ww5 :: GHC.Prim.Int#)
                   (ww6 :: GHC.Prim.Int#)
                   (ww7 :: GHC.Prim.ByteArray#) ->
                 case GHC.Prim.==# ww1 ww6 of lwild {
                   DEFAULT -> Statistics.Matrix.$wlvl ww6 ww1
                   1#
                   -> case GHC.Magic.runRW#
                             @ ('GHC.Types.TupleRep
                                  '['GHC.Types.TupleRep '[], 'GHC.Types.LiftedRep])
                             @ (# GHC.Prim.State# GHC.Prim.RealWorld,
                                  Data.Vector.Unboxed.Base.Vector GHC.Types.Double #)
                             (\ (s1 :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                              let {
                                $w$j :: GHC.Prim.Int#
                                        -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                              Data.Vector.Unboxed.Base.Vector GHC.Types.Double #)
                                  <join 1> {- Arity: 1, Strictness: <S,U>, Inline: [0] -}
                                = \ (w :: GHC.Prim.Int#)[OneShot] ->
                                  case GHC.Prim.<# w 0# of lwild1 {
                                    DEFAULT
                                    -> case GHC.Prim.># w 1152921504606846975# of lwild2 {
                                         DEFAULT
                                         -> case GHC.Prim.newByteArray#
                                                   @ (Control.Monad.Primitive.PrimState
                                                        (GHC.ST.ST GHC.Prim.RealWorld))
                                                   (GHC.Prim.*# w 8#)
                                                   s1
                                                     `cast`
                                                   (GHC.Prim.State#
                                                      (Sym (Control.Monad.Primitive.D:R:PrimStateST[0]
                                                                <GHC.Prim.RealWorld>_N)))_R of ds1 { (#,#) ipv ipv1 ->
                                            let {
                                              exit :: GHC.Prim.Int#
                                                      -> GHC.Prim.State# GHC.Prim.RealWorld
                                                      -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                                            Data.Vector.Unboxed.Base.Vector
                                                              GHC.Types.Double #)
                                                <join 2> {- Arity: 2, Strictness: <L,U><S,U> -}
                                              = \ (ww8 :: GHC.Prim.Int#)[OneShot]
                                                  (w1 :: GHC.Prim.State#
                                                           GHC.Prim.RealWorld)[OneShot] ->
                                                case GHC.Prim.unsafeFreezeByteArray#
                                                       @ (Control.Monad.Primitive.PrimState
                                                            (GHC.ST.ST GHC.Prim.RealWorld))
                                                       ipv1
                                                       w1
                                                         `cast`
                                                       (GHC.Prim.State#
                                                          (Sym (Control.Monad.Primitive.D:R:PrimStateST[0]
                                                                    <GHC.Prim.RealWorld>_N)))_R of ds2 { (#,#) ipv2 ipv3 ->
                                                (# ipv2
                                                     `cast`
                                                   (GHC.Prim.State#
                                                      (Control.Monad.Primitive.D:R:PrimStateST[0]
                                                           <GHC.Prim.RealWorld>_N))_R,
                                                   (Data.Vector.Primitive.Vector
                                                      @ GHC.Types.Double
                                                      0#
                                                      ww8
                                                      ipv3)
                                                     `cast`
                                                   (Sym (Data.Vector.Unboxed.Base.N:R:VectorDouble[0]) ; Sym (Data.Vector.Unboxed.Base.D:R:VectorDouble0[0])) #) }
                                            } in
                                            let {
                                              exit1 :: GHC.Prim.Int#
                                                       -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                                             Data.Vector.Unboxed.Base.Vector
                                                               GHC.Types.Double #)
                                                <join 1> {- Arity: 1, Strictness: <B,U>b -}
                                              = \ (i :: GHC.Prim.Int#)[OneShot] ->
                                                case Statistics.Matrix.multiplyV1 ww1 i ww3
                                                ret_ty (# GHC.Prim.State# GHC.Prim.RealWorld,
                                                          Data.Vector.Unboxed.Base.Vector
                                                            GHC.Types.Double #)
                                                of {}
                                            } in
                                            letrec {
                                              $wfoldlM'_loop :: GHC.Types.SPEC
                                                                -> GHC.Prim.Int#
                                                                -> GHC.Prim.Int#
                                                                -> GHC.Prim.State#
                                                                     GHC.Prim.RealWorld
                                                                -> (# GHC.Prim.State#
                                                                        GHC.Prim.RealWorld,
                                                                      Data.Vector.Unboxed.Base.Vector
                                                                        GHC.Types.Double #)
                                                <join 4> {- Arity: 4,
                                                            Strictness: <S,1*U><S,U><S,U><S,U>,
                                                            Inline: [0] -}
                                              = \ (w1 :: GHC.Types.SPEC)
                                                  (ww8 :: GHC.Prim.Int#)
                                                  (ww9 :: GHC.Prim.Int#)
                                                  (w2 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                                                case w1 of ds5 { DEFAULT ->
                                                case GHC.Prim.<# ww9 ww of lwild3 {
                                                  DEFAULT -> exit ww8 w2
                                                  1#
                                                  -> let {
                                                       i :: GHC.Prim.Int# = GHC.Prim.*# ww1 ww9
                                                     } in
                                                     case GHC.Prim.>=# i 0# of lwild4 {
                                                       DEFAULT -> exit1 i
                                                       1#
                                                       -> case GHC.Prim.>=# ww1 0# of lwild5 {
                                                            DEFAULT -> exit1 i
                                                            1#
                                                            -> case GHC.Prim.<=#
                                                                      (GHC.Prim.+# i ww1)
                                                                      ww3 of lwild6 {
                                                                 DEFAULT -> exit1 i
                                                                 1#
                                                                 -> let {
                                                                      ipv2 :: GHC.Prim.Int#
                                                                      = GHC.Prim.+# ww2 i
                                                                    } in
                                                                    let {
                                                                      $j :: GHC.Prim.Double#
                                                                            -> GHC.Prim.Double#
                                                                            -> (# GHC.Prim.State#
                                                                                    GHC.Prim.RealWorld,
                                                                                  Data.Vector.Unboxed.Base.Vector
                                                                                    GHC.Types.Double #)
                                                                        <join 2> {- Arity: 2,
                                                                                    Strictness: <S,U><S,U> -}
                                                                      = \ (dt :: GHC.Prim.Double#)[OneShot]
                                                                          (dt1 :: GHC.Prim.Double#)[OneShot] ->
                                                                        case GHC.Prim.writeDoubleArray#
                                                                               @ (Control.Monad.Primitive.PrimState
                                                                                    (GHC.ST.ST
                                                                                       GHC.Prim.RealWorld))
                                                                               ipv1
                                                                               ww8
                                                                               (GHC.Prim.+## dt dt1)
                                                                               w2
                                                                                 `cast`
                                                                               (GHC.Prim.State#
                                                                                  (Sym (Control.Monad.Primitive.D:R:PrimStateST[0]
                                                                                            <GHC.Prim.RealWorld>_N)))_R of s'# { DEFAULT ->
                                                                        $wfoldlM'_loop
                                                                          GHC.Types.SPEC
                                                                          (GHC.Prim.+# ww8 1#)
                                                                          (GHC.Prim.+# ww9 1#)
                                                                          s'#
                                                                            `cast`
                                                                          (GHC.Prim.State#
                                                                             (Control.Monad.Primitive.D:R:PrimStateST[0]
                                                                                  <GHC.Prim.RealWorld>_N))_R }
                                                                    } in
                                                                    letrec {
                                                                      $wfoldlM'_loop1 :: GHC.Types.SPEC
                                                                                         -> GHC.Prim.Double#
                                                                                         -> GHC.Prim.Double#
                                                                                         -> GHC.Types.Int
                                                                                         -> GHC.Types.Int
                                                                                         -> GHC.Base.Maybe
                                                                                              GHC.Types.Double
                                                                                         -> (# GHC.Prim.State#
                                                                                                 GHC.Prim.RealWorld,
                                                                                               Data.Vector.Unboxed.Base.Vector
                                                                                                 GHC.Types.Double #)
                                                                        <join 6> {- Arity: 6,
                                                                                    Strictness: <S,1*U><S,U><S,U><L,1*U(U)><L,1*U(U)><S,1*U>,
                                                                                    Inline: [0] -}
                                                                      = \ (w3 :: GHC.Types.SPEC)
                                                                          (ww10 :: GHC.Prim.Double#)
                                                                          (ww11 :: GHC.Prim.Double#)
                                                                          (ww12 :: GHC.Types.Int)
                                                                          (ww13 :: GHC.Types.Int)
                                                                          (ww14 :: GHC.Base.Maybe
                                                                                     GHC.Types.Double) ->
                                                                        case w3 of ds2 { DEFAULT ->
                                                                        case ww14 of wild5 {
                                                                          GHC.Base.Nothing
                                                                          -> case ww12 of wild { GHC.Types.I# x ->
                                                                             case GHC.Prim.>=#
                                                                                    x
                                                                                    ww6 of lwild7 {
                                                                               DEFAULT
                                                                               -> case GHC.Prim.indexDoubleArray#
                                                                                         ww7
                                                                                         (GHC.Prim.+#
                                                                                            ww5
                                                                                            x) of wild2 { DEFAULT ->
                                                                                  $wfoldlM'_loop1
                                                                                    GHC.Types.SPEC
                                                                                    ww10
                                                                                    ww11
                                                                                    (GHC.Types.I#
                                                                                       (GHC.Prim.+#
                                                                                          x
                                                                                          1#))
                                                                                    ww13
                                                                                    (GHC.Base.Just
                                                                                       @ GHC.Types.Double
                                                                                       (GHC.Types.D#
                                                                                          wild2)) }
                                                                               1#
                                                                               -> $j ww10 ww11 } }
                                                                          GHC.Base.Just x
                                                                          -> case ww13 of wild { GHC.Types.I# x1 ->
                                                                             case GHC.Prim.>=#
                                                                                    x1
                                                                                    ww1 of lwild7 {
                                                                               DEFAULT
                                                                               -> case GHC.Prim.indexDoubleArray#
                                                                                         ww4
                                                                                         (GHC.Prim.+#
                                                                                            ipv2
                                                                                            x1) of wild2 { DEFAULT ->
                                                                                  case x of wild1 { GHC.Types.D# x2 ->
                                                                                  let {
                                                                                    y :: GHC.Prim.Double#
                                                                                    = GHC.Prim.*##
                                                                                        x2
                                                                                        wild2
                                                                                  } in
                                                                                  let {
                                                                                    dt2 :: GHC.Prim.Double#
                                                                                    = GHC.Prim.+##
                                                                                        ww10
                                                                                        y
                                                                                  } in
                                                                                  case GHC.Prim.>=##
                                                                                         (GHC.Prim.fabsDouble#
                                                                                            ww10)
                                                                                         (GHC.Prim.fabsDouble#
                                                                                            y) of lwild8 {
                                                                                    DEFAULT
                                                                                    -> $wfoldlM'_loop1
                                                                                         GHC.Types.SPEC
                                                                                         dt2
                                                                                         (GHC.Prim.+##
                                                                                            ww11
                                                                                            (GHC.Prim.+##
                                                                                               (GHC.Prim.-##
                                                                                                  y
                                                                                                  dt2)
                                                                                               ww10))
                                                                                         ww12
                                                                                         (GHC.Types.I#
                                                                                            (GHC.Prim.+#
                                                                                               x1
                                                                                               1#))
                                                                                         (GHC.Base.Nothing
                                                                                            @ GHC.Types.Double)
                                                                                    1#
                                                                                    -> $wfoldlM'_loop1
                                                                                         GHC.Types.SPEC
                                                                                         dt2
                                                                                         (GHC.Prim.+##
                                                                                            ww11
                                                                                            (GHC.Prim.+##
                                                                                               (GHC.Prim.-##
                                                                                                  ww10
                                                                                                  dt2)
                                                                                               y))
                                                                                         ww12
                                                                                         (GHC.Types.I#
                                                                                            (GHC.Prim.+#
                                                                                               x1
                                                                                               1#))
                                                                                         (GHC.Base.Nothing
                                                                                            @ GHC.Types.Double) } } }
                                                                               1#
                                                                               -> $j
                                                                                    ww10
                                                                                    ww11 } } } }
                                                                    } in
                                                                    $wfoldlM'_loop1
                                                                      GHC.Types.SPEC
                                                                      0.0##
                                                                      0.0##
                                                                      Statistics.Matrix.diag1
                                                                      Statistics.Matrix.diag1
                                                                      (GHC.Base.Nothing
                                                                         @ GHC.Types.Double) } } } } }
                                            } in
                                            $wfoldlM'_loop
                                              GHC.Types.SPEC
                                              0#
                                              0#
                                              ipv
                                                `cast`
                                              (GHC.Prim.State#
                                                 (Control.Monad.Primitive.D:R:PrimStateST[0]
                                                      <GHC.Prim.RealWorld>_N))_R }
                                         1#
                                         -> case Statistics.Matrix.fromRows5 w
                                            ret_ty (# GHC.Prim.State# GHC.Prim.RealWorld,
                                                      Data.Vector.Unboxed.Base.Vector
                                                        GHC.Types.Double #)
                                            of {} }
                                    1#
                                    -> case Statistics.Matrix.fromRows4 w
                                       ret_ty (# GHC.Prim.State# GHC.Prim.RealWorld,
                                                 Data.Vector.Unboxed.Base.Vector GHC.Types.Double #)
                                       of {} }
                              } in
                              case GHC.Prim.<=# ww 0# of lwild1 {
                                DEFAULT -> $w$j ww 1# -> $w$j 0# }) of ds1 { (#,#) ipv1 ipv2 ->
                      ipv2 } }) -}
c88763c404978744b41ba92e8be22298
  $wnorm ::
    GHC.Prim.Int#
    -> GHC.Prim.Int# -> GHC.Prim.ByteArray# -> GHC.Prim.Double#
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U><S,U><L,U>,
     Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#)
                   (ww1 :: GHC.Prim.Int#)
                   (ww2 :: GHC.Prim.ByteArray#) ->
                 letrec {
                   $wfoldlM'_loop :: GHC.Types.SPEC
                                     -> GHC.Prim.Double#
                                     -> GHC.Prim.Double#
                                     -> GHC.Prim.Int#
                                     -> GHC.Prim.Double#
                     <join 4> {- Arity: 4, Strictness: <S,1*U><S,U><S,U><S,U>,
                                 Inline: [0] -}
                   = \ (w :: GHC.Types.SPEC)
                       (ww3 :: GHC.Prim.Double#)
                       (ww4 :: GHC.Prim.Double#)
                       (ww5 :: GHC.Prim.Int#) ->
                     case w of ds5 { DEFAULT ->
                     case GHC.Prim.>=# ww5 ww1 of lwild {
                       DEFAULT
                       -> case GHC.Prim.indexDoubleArray#
                                 ww2
                                 (GHC.Prim.+# ww ww5) of wild2 { DEFAULT ->
                          let {
                            y :: GHC.Prim.Double# = GHC.Prim.*## wild2 wild2
                          } in
                          let {
                            dt2 :: GHC.Prim.Double# = GHC.Prim.+## ww3 y
                          } in
                          case GHC.Prim.>=##
                                 (GHC.Prim.fabsDouble# ww3)
                                 (GHC.Prim.fabsDouble# y) of lwild1 {
                            DEFAULT
                            -> $wfoldlM'_loop
                                 GHC.Types.SPEC
                                 dt2
                                 (GHC.Prim.+## ww4 (GHC.Prim.+## (GHC.Prim.-## y dt2) ww3))
                                 (GHC.Prim.+# ww5 1#)
                            1#
                            -> $wfoldlM'_loop
                                 GHC.Types.SPEC
                                 dt2
                                 (GHC.Prim.+## ww4 (GHC.Prim.+## (GHC.Prim.-## ww3 dt2) y))
                                 (GHC.Prim.+# ww5 1#) } }
                       1# -> GHC.Prim.sqrtDouble# (GHC.Prim.+## ww3 ww4) } }
                 } in
                 $wfoldlM'_loop GHC.Types.SPEC 0.0## 0.0## 0#) -}
502e6262d8eb5fb539a8bac131b433c6
  $wpower ::
    GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> Statistics.Matrix.Types.Vector
    -> GHC.Prim.Int#
    -> (# GHC.Prim.Int#, GHC.Prim.Int#,
          Statistics.Matrix.Types.Vector #)
  {- Arity: 4, Strictness: <S,U><S,U><S,1*U(U,U,U)><S,1*U>,
     Inline: [0] -}
b556dcd14caaf1060e6fbd5f990a4170
  $wrow ::
    GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Prim.ByteArray#
    -> GHC.Prim.Int#
    -> (# GHC.Prim.Int#, GHC.Prim.Int#, GHC.Prim.ByteArray# #)
  {- Arity: 5, Strictness: <S,U><S,U><S,U><S,U><S,U>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#)
                   (ww1 :: GHC.Prim.Int#)
                   (ww2 :: GHC.Prim.Int#)
                   (ww3 :: GHC.Prim.ByteArray#)
                   (ww4 :: GHC.Prim.Int#) ->
                 let {
                   i :: GHC.Prim.Int# = GHC.Prim.*# ww ww4
                 } in
                 case GHC.Prim.>=# i 0# of lwild {
                   DEFAULT
                   -> case Statistics.Matrix.multiplyV1 ww i ww2
                      ret_ty (# GHC.Prim.Int#, GHC.Prim.Int#, GHC.Prim.ByteArray# #)
                      of {}
                   1#
                   -> case GHC.Prim.>=# ww 0# of lwild1 {
                        DEFAULT
                        -> case Statistics.Matrix.multiplyV1 ww i ww2
                           ret_ty (# GHC.Prim.Int#, GHC.Prim.Int#, GHC.Prim.ByteArray# #)
                           of {}
                        1#
                        -> case GHC.Prim.<=# (GHC.Prim.+# i ww) ww2 of lwild2 {
                             DEFAULT
                             -> case Statistics.Matrix.multiplyV1 ww i ww2
                                ret_ty (# GHC.Prim.Int#, GHC.Prim.Int#, GHC.Prim.ByteArray# #)
                                of {}
                             1# -> (# GHC.Prim.+# ww1 i, ww, ww3 #) } } }) -}
59cd3e566c5cf36cb2e6610ac3d2b008
  $wtoList ::
    GHC.Prim.Int#
    -> GHC.Prim.Int# -> GHC.Prim.ByteArray# -> [GHC.Types.Double]
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U><S,U><L,U>,
     Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#)
                   (ww1 :: GHC.Prim.Int#)
                   (ww2 :: GHC.Prim.ByteArray#) ->
                 letrec {
                   $wgo1 :: GHC.Prim.Int# -> [GHC.Types.Double]
                     {- Arity: 1, Strictness: <S,U>, Inline: [0] -}
                   = \ (ww3 :: GHC.Prim.Int#) ->
                     case GHC.Prim.>=# ww3 ww1 of lwild {
                       DEFAULT
                       -> case GHC.Prim.indexDoubleArray#
                                 ww2
                                 (GHC.Prim.+# ww ww3) of wild2 { DEFAULT ->
                          GHC.Types.:
                            @ GHC.Types.Double
                            (GHC.Types.D# wild2)
                            ($wgo1 (GHC.Prim.+# ww3 1#)) }
                       1# -> GHC.Types.[] @ GHC.Types.Double }
                 } in
                 $wgo1 0#) -}
9ca6eb0ea8af46a971153b61da09496e
  $wtoRowLists ::
    GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Prim.ByteArray#
    -> [[GHC.Types.Double]]
  {- Arity: 4, HasNoCafRefs, Strictness: <L,U><L,U><S,U><L,U>,
     Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#)
                   (ww1 :: GHC.Prim.Int#)
                   (ww2 :: GHC.Prim.Int#)
                   (ww3 :: GHC.Prim.ByteArray#) ->
                 letrec {
                   chunks :: [GHC.Types.Double] -> [[GHC.Types.Double]]
                     {- Arity: 1, Strictness: <S,1*U> -}
                   = \ (ds :: [GHC.Types.Double]) ->
                     case ds of wild {
                       [] -> GHC.Types.[] @ [GHC.Types.Double]
                       : ipv ipv1
                       -> case GHC.Prim.<=# ww 0# of lwild {
                            DEFAULT
                            -> case ww of ds1 {
                                 DEFAULT
                                 -> let {
                                      ds2 :: ([GHC.Types.Double], [GHC.Types.Double])
                                      = case GHC.List.splitAt_$s$wsplitAt'
                                               @ GHC.Types.Double
                                               ipv1
                                               (GHC.Prim.-# ds1 1#) of ww4 { (#,#) ww5 ww6 ->
                                        (ww5, ww6) }
                                    } in
                                    GHC.Types.:
                                      @ [GHC.Types.Double]
                                      (GHC.Types.:
                                         @ GHC.Types.Double
                                         ipv
                                         (case ds2 of wild2 { (,) xs' xs'' -> xs' }))
                                      (case ds2 of wild2 { (,) xs' xs'' -> chunks xs'' })
                                 1#
                                 -> GHC.Types.:
                                      @ [GHC.Types.Double]
                                      (GHC.Types.:
                                         @ GHC.Types.Double
                                         ipv
                                         (GHC.Types.[] @ GHC.Types.Double))
                                      (chunks ipv1) }
                            1#
                            -> GHC.Types.:
                                 @ [GHC.Types.Double]
                                 (GHC.Types.[] @ GHC.Types.Double)
                                 (chunks wild) } }
                 } in
                 letrec {
                   $wgo1 :: GHC.Prim.Int# -> [GHC.Types.Double]
                     {- Arity: 1, Strictness: <S,U>, Inline: [0] -}
                   = \ (ww4 :: GHC.Prim.Int#) ->
                     case GHC.Prim.>=# ww4 ww2 of lwild {
                       DEFAULT
                       -> case GHC.Prim.indexDoubleArray#
                                 ww3
                                 (GHC.Prim.+# ww1 ww4) of wild2 { DEFAULT ->
                          GHC.Types.:
                            @ GHC.Types.Double
                            (GHC.Types.D# wild2)
                            ($wgo1 (GHC.Prim.+# ww4 1#)) }
                       1# -> GHC.Types.[] @ GHC.Types.Double }
                 } in
                 chunks ($wgo1 0#)) -}
b4534c878b47f6f5f2e5e144a88f855f
  $wtoRows ::
    GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Prim.ByteArray#
    -> [Statistics.Matrix.Types.Vector]
  {- Arity: 4, HasNoCafRefs, Strictness: <L,U><S,U><S,1*U><S,U>,
     Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#)
                   (ww1 :: GHC.Prim.Int#)
                   (ww2 :: GHC.Prim.Int#)
                   (ww3 :: GHC.Prim.ByteArray#) ->
                 let {
                   n' :: GHC.Types.Int
                   = case GHC.Prim.<=# ww 0# of lwild {
                       DEFAULT -> GHC.Types.I# ww 1# -> Statistics.Matrix.diag1 }
                 } in
                 letrec {
                   $wchunks :: GHC.Prim.Int#
                               -> GHC.Prim.Int#
                               -> GHC.Prim.ByteArray#
                               -> [Data.Vector.Unboxed.Base.Vector GHC.Types.Double]
                     {- Arity: 3, Strictness: <L,U><S,1*U><L,U>, Inline: [0] -}
                   = \ (ww4 :: GHC.Prim.Int#)
                       (ww5 :: GHC.Prim.Int#)
                       (ww6 :: GHC.Prim.ByteArray#) ->
                     case ww5 of wild3 {
                       DEFAULT
                       -> let {
                            m :: GHC.Types.Int
                            = case n' of wild { GHC.Types.I# x1 ->
                              case GHC.Prim.<=# x1 wild3 of lwild {
                                DEFAULT -> GHC.Types.I# wild3 1# -> wild } }
                          } in
                          GHC.Types.:
                            @ (Data.Vector.Unboxed.Base.Vector GHC.Types.Double)
                            (case m of dt { GHC.Types.I# dt1 ->
                             (Data.Vector.Primitive.Vector @ GHC.Types.Double ww4 dt1 ww6)
                               `cast`
                             (Sym (Data.Vector.Unboxed.Base.N:R:VectorDouble[0]) ; Sym (Data.Vector.Unboxed.Base.D:R:VectorDouble0[0])) })
                            (case m of wild1 { GHC.Types.I# y ->
                             case n' of wild2 { GHC.Types.I# y1 ->
                             let {
                               y2 :: GHC.Prim.Int# = GHC.Prim.-# wild3 y1
                             } in
                             case GHC.Prim.<=# 0# y2 of lwild {
                               DEFAULT -> $wchunks (GHC.Prim.+# ww4 y) 0# ww6
                               1# -> $wchunks (GHC.Prim.+# ww4 y) y2 ww6 } } })
                       0#
                       -> GHC.Types.[]
                            @ (Data.Vector.Unboxed.Base.Vector GHC.Types.Double) }
                 } in
                 $wchunks ww1 ww2 ww3) -}
b94ccc8076341730a86e7671ea04fd40
  $wtranspose ::
    GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Prim.ByteArray#
    -> (# GHC.Prim.Int#, GHC.Prim.Int#,
          Statistics.Matrix.Types.Vector #)
  {- Arity: 4, Strictness: <S,U><S,U><L,U><L,U>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#)
                   (ww1 :: GHC.Prim.Int#)
                   (ww2 :: GHC.Prim.Int#)
                   (ww3 :: GHC.Prim.ByteArray#) ->
                 case GHC.Magic.runRW#
                        @ ('GHC.Types.TupleRep
                             '['GHC.Types.TupleRep '[], 'GHC.Types.LiftedRep])
                        @ (# GHC.Prim.State# GHC.Prim.RealWorld,
                             Data.Vector.Unboxed.Base.Vector GHC.Types.Double #)
                        (\ (s1 :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                         let {
                           n :: GHC.Prim.Int# = GHC.Prim.*# ww ww1
                         } in
                         let {
                           $w$j :: GHC.Prim.Int#
                                   -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                         Data.Vector.Unboxed.Base.Vector GHC.Types.Double #)
                             <join 1> {- Arity: 1, Strictness: <S,U>, Inline: [0] -}
                           = \ (w :: GHC.Prim.Int#)[OneShot] ->
                             case GHC.Prim.<# w 0# of lwild {
                               DEFAULT
                               -> case GHC.Prim.># w 1152921504606846975# of lwild1 {
                                    DEFAULT
                                    -> case GHC.Prim.newByteArray#
                                              @ (Control.Monad.Primitive.PrimState
                                                   (GHC.ST.ST GHC.Prim.RealWorld))
                                              (GHC.Prim.*# w 8#)
                                              s1
                                                `cast`
                                              (GHC.Prim.State#
                                                 (Sym (Control.Monad.Primitive.D:R:PrimStateST[0]
                                                           <GHC.Prim.RealWorld>_N)))_R of ds1 { (#,#) ipv ipv1 ->
                                       let {
                                         exit :: GHC.Prim.Int#
                                                 -> GHC.Prim.State# GHC.Prim.RealWorld
                                                 -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                                       Data.Vector.Unboxed.Base.Vector
                                                         GHC.Types.Double #)
                                           <join 2> {- Arity: 2, Strictness: <L,U><S,U> -}
                                         = \ (ww4 :: GHC.Prim.Int#)[OneShot]
                                             (w1 :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                                           case GHC.Prim.unsafeFreezeByteArray#
                                                  @ (Control.Monad.Primitive.PrimState
                                                       (GHC.ST.ST GHC.Prim.RealWorld))
                                                  ipv1
                                                  w1
                                                    `cast`
                                                  (GHC.Prim.State#
                                                     (Sym (Control.Monad.Primitive.D:R:PrimStateST[0]
                                                               <GHC.Prim.RealWorld>_N)))_R of ds2 { (#,#) ipv2 ipv3 ->
                                           (# ipv2
                                                `cast`
                                              (GHC.Prim.State#
                                                 (Control.Monad.Primitive.D:R:PrimStateST[0]
                                                      <GHC.Prim.RealWorld>_N))_R,
                                              (Data.Vector.Primitive.Vector
                                                 @ GHC.Types.Double
                                                 0#
                                                 ww4
                                                 ipv3)
                                                `cast`
                                              (Sym (Data.Vector.Unboxed.Base.N:R:VectorDouble[0]) ; Sym (Data.Vector.Unboxed.Base.D:R:VectorDouble0[0])) #) }
                                       } in
                                       letrec {
                                         $wfoldlM'_loop :: GHC.Types.SPEC
                                                           -> GHC.Prim.Int#
                                                           -> GHC.Prim.Int#
                                                           -> GHC.Prim.State# GHC.Prim.RealWorld
                                                           -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                                                 Data.Vector.Unboxed.Base.Vector
                                                                   GHC.Types.Double #)
                                           <join 4> {- Arity: 4, Strictness: <S,1*U><S,U><S,U><S,U>,
                                                       Inline: [0] -}
                                         = \ (w1 :: GHC.Types.SPEC)
                                             (ww4 :: GHC.Prim.Int#)
                                             (ww5 :: GHC.Prim.Int#)
                                             (w2 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                                           case w1 of ds5 { DEFAULT ->
                                           case GHC.Prim.<# ww5 n of lwild2 {
                                             DEFAULT -> exit ww4 w2
                                             1#
                                             -> case ww of wild {
                                                  DEFAULT
                                                  -> case GHC.Prim.quotRemInt#
                                                            ww5
                                                            wild of ds2 { (#,#) ipv2 ipv3 ->
                                                     case GHC.Prim.indexDoubleArray#
                                                            ww3
                                                            (GHC.Prim.+#
                                                               ww2
                                                               (GHC.Prim.+#
                                                                  (GHC.Prim.*# ipv3 ww1)
                                                                  ipv2)) of wild2 { DEFAULT ->
                                                     case GHC.Prim.writeDoubleArray#
                                                            @ (Control.Monad.Primitive.PrimState
                                                                 (GHC.ST.ST GHC.Prim.RealWorld))
                                                            ipv1
                                                            ww4
                                                            wild2
                                                            w2
                                                              `cast`
                                                            (GHC.Prim.State#
                                                               (Sym (Control.Monad.Primitive.D:R:PrimStateST[0]
                                                                         <GHC.Prim.RealWorld>_N)))_R of s'# { DEFAULT ->
                                                     $wfoldlM'_loop
                                                       GHC.Types.SPEC
                                                       (GHC.Prim.+# ww4 1#)
                                                       (GHC.Prim.+# ww5 1#)
                                                       s'#
                                                         `cast`
                                                       (GHC.Prim.State#
                                                          (Control.Monad.Primitive.D:R:PrimStateST[0]
                                                               <GHC.Prim.RealWorld>_N))_R } } }
                                                  -1#
                                                  -> case ww5 of wild1 {
                                                       DEFAULT
                                                       -> case GHC.Prim.quotRemInt#
                                                                 wild1
                                                                 -1# of ds2 { (#,#) ipv2 ipv3 ->
                                                          case GHC.Prim.indexDoubleArray#
                                                                 ww3
                                                                 (GHC.Prim.+#
                                                                    ww2
                                                                    (GHC.Prim.+#
                                                                       (GHC.Prim.*# ipv3 ww1)
                                                                       ipv2)) of wild2 { DEFAULT ->
                                                          case GHC.Prim.writeDoubleArray#
                                                                 @ (Control.Monad.Primitive.PrimState
                                                                      (GHC.ST.ST
                                                                         GHC.Prim.RealWorld))
                                                                 ipv1
                                                                 ww4
                                                                 wild2
                                                                 w2
                                                                   `cast`
                                                                 (GHC.Prim.State#
                                                                    (Sym (Control.Monad.Primitive.D:R:PrimStateST[0]
                                                                              <GHC.Prim.RealWorld>_N)))_R of s'# { DEFAULT ->
                                                          $wfoldlM'_loop
                                                            GHC.Types.SPEC
                                                            (GHC.Prim.+# ww4 1#)
                                                            (GHC.Prim.+# wild1 1#)
                                                            s'#
                                                              `cast`
                                                            (GHC.Prim.State#
                                                               (Control.Monad.Primitive.D:R:PrimStateST[0]
                                                                    <GHC.Prim.RealWorld>_N))_R } } }
                                                       -9223372036854775808#
                                                       -> case GHC.Real.overflowError
                                                          ret_ty (# GHC.Prim.State#
                                                                      GHC.Prim.RealWorld,
                                                                    Data.Vector.Unboxed.Base.Vector
                                                                      GHC.Types.Double #)
                                                          of {} }
                                                  0#
                                                  -> case GHC.Real.divZeroError
                                                     ret_ty (# GHC.Prim.State# GHC.Prim.RealWorld,
                                                               Data.Vector.Unboxed.Base.Vector
                                                                 GHC.Types.Double #)
                                                     of {} } } }
                                       } in
                                       $wfoldlM'_loop
                                         GHC.Types.SPEC
                                         0#
                                         0#
                                         ipv
                                           `cast`
                                         (GHC.Prim.State#
                                            (Control.Monad.Primitive.D:R:PrimStateST[0]
                                                 <GHC.Prim.RealWorld>_N))_R }
                                    1#
                                    -> case Statistics.Matrix.fromRows5 w
                                       ret_ty (# GHC.Prim.State# GHC.Prim.RealWorld,
                                                 Data.Vector.Unboxed.Base.Vector GHC.Types.Double #)
                                       of {} }
                               1#
                               -> case Statistics.Matrix.fromRows4 w
                                  ret_ty (# GHC.Prim.State# GHC.Prim.RealWorld,
                                            Data.Vector.Unboxed.Base.Vector GHC.Types.Double #)
                                  of {} }
                         } in
                         case GHC.Prim.<=# n 0# of lwild {
                           DEFAULT -> $w$j n 1# -> $w$j 0# }) of ds1 { (#,#) ipv1 ipv2 ->
                 case ipv2
                        `cast`
                      (Data.Vector.Unboxed.Base.D:R:VectorDouble0[0] ; Data.Vector.Unboxed.Base.N:R:VectorDouble[0]) of nt { Data.Vector.Primitive.Vector ipv ipv4 ipv5 ->
                 (# ww1, ww,
                    nt
                      `cast`
                    (Sym (Data.Vector.Unboxed.Base.N:R:VectorDouble[0]) ; Sym (Data.Vector.Unboxed.Base.D:R:VectorDouble0[0])) #) } }) -}
bf90129c5cb6f410b522c52e017f9b6a
  bounds ::
    (Statistics.Matrix.Types.Vector -> GHC.Types.Int -> r)
    -> Statistics.Matrix.Types.Matrix
    -> GHC.Types.Int
    -> GHC.Types.Int
    -> r
  {- Arity: 4,
     Strictness: <C(C(S)),1*C1(C1(U))><S(SSS),1*U(U,U,U)><S(S),1*U(U)><S(S),1*U(U)>,
     Inline: (sat-args=4),
     Unfolding: InlineRule (4, False, False)
                (\ @ r ->
                 let {
                   loc7 :: [GHC.Types.Char]
                   = GHC.Base.build
                       @ GHC.Types.Char
                       (\ @ b ->
                        GHC.CString.unpackFoldrCString#
                          @ b
                          "dense-linear-algebra-0.1.0.0-Elr9WMmlb0BKsm96yzG2PQ"#)
                 } in
                 let {
                   loc8 :: [GHC.Types.Char]
                   = GHC.Base.build
                       @ GHC.Types.Char
                       (\ @ b -> GHC.CString.unpackFoldrCString# @ b "Statistics.Matrix"#)
                 } in
                 let {
                   loc9 :: [GHC.Types.Char]
                   = GHC.Base.build
                       @ GHC.Types.Char
                       (\ @ b ->
                        GHC.CString.unpackFoldrCString# @ b "src/Statistics/Matrix.hs"#)
                 } in
                 let {
                   loc10 :: GHC.Types.Int = GHC.Types.I# 252#
                 } in
                 let {
                   loc11 :: GHC.Types.Int = GHC.Types.I# 24#
                 } in
                 let {
                   loc12 :: GHC.Types.Int = GHC.Types.I# 252#
                 } in
                 let {
                   loc13 :: GHC.Types.Int = GHC.Types.I# 52#
                 } in
                 let {
                   $dIP2 :: [GHC.Types.Char]
                   = GHC.Base.build
                       @ GHC.Types.Char
                       (\ @ b -> GHC.CString.unpackFoldrCString# @ b "error"#)
                 } in
                 let {
                   $dIP3 :: GHC.Stack.Types.SrcLoc
                   = GHC.Stack.Types.SrcLoc loc7 loc8 loc9 loc10 loc11 loc12 loc13
                 } in
                 let {
                   $dIP4 :: GHC.Stack.Types.CallStack
                   = GHC.Stack.Types.PushCallStack
                       $dIP2
                       $dIP3
                       GHC.Stack.Types.EmptyCallStack
                 } in
                 let {
                   loc14 :: [GHC.Types.Char]
                   = GHC.Base.build
                       @ GHC.Types.Char
                       (\ @ b ->
                        GHC.CString.unpackFoldrCString#
                          @ b
                          "dense-linear-algebra-0.1.0.0-Elr9WMmlb0BKsm96yzG2PQ"#)
                 } in
                 let {
                   loc15 :: [GHC.Types.Char]
                   = GHC.Base.build
                       @ GHC.Types.Char
                       (\ @ b -> GHC.CString.unpackFoldrCString# @ b "Statistics.Matrix"#)
                 } in
                 let {
                   loc16 :: [GHC.Types.Char]
                   = GHC.Base.build
                       @ GHC.Types.Char
                       (\ @ b ->
                        GHC.CString.unpackFoldrCString# @ b "src/Statistics/Matrix.hs"#)
                 } in
                 let {
                   loc17 :: GHC.Types.Int = GHC.Types.I# 251#
                 } in
                 let {
                   loc18 :: GHC.Types.Int = GHC.Types.I# 24#
                 } in
                 let {
                   loc19 :: GHC.Types.Int = GHC.Types.I# 251#
                 } in
                 let {
                   loc20 :: GHC.Types.Int = GHC.Types.I# 49#
                 } in
                 let {
                   $dIP5 :: [GHC.Types.Char]
                   = GHC.Base.build
                       @ GHC.Types.Char
                       (\ @ b -> GHC.CString.unpackFoldrCString# @ b "error"#)
                 } in
                 let {
                   $dIP6 :: GHC.Stack.Types.SrcLoc
                   = GHC.Stack.Types.SrcLoc loc14 loc15 loc16 loc17 loc18 loc19 loc20
                 } in
                 let {
                   $dIP7 :: GHC.Stack.Types.CallStack
                   = GHC.Stack.Types.PushCallStack
                       $dIP5
                       $dIP6
                       GHC.Stack.Types.EmptyCallStack
                 } in
                 \ (k :: Statistics.Matrix.Types.Vector -> GHC.Types.Int -> r)
                   (ds :: Statistics.Matrix.Types.Matrix)
                   (r1 :: GHC.Types.Int)
                   (c :: GHC.Types.Int) ->
                 case ds of wild { Statistics.Matrix.Types.Matrix dt dt1 v ->
                 let {
                   $j :: r <join 0>
                   = GHC.Err.error
                       @ 'GHC.Types.LiftedRep
                       @ r
                       $dIP7
                         `cast`
                       (Sym (GHC.Classes.N:IP[0]
                                 <"callStack">_N <GHC.Stack.Types.CallStack>_N))
                       (GHC.Base.build
                          @ GHC.Types.Char
                          (\ @ b ->
                           GHC.CString.unpackFoldrCString# @ b "row out of bounds"#))
                 } in
                 case GHC.Classes.ltInt r1 (GHC.Types.I# 0#) of wild1 {
                   GHC.Types.False
                   -> case GHC.Classes.geInt r1 (GHC.Types.I# dt) of wild2 {
                        GHC.Types.False
                        -> let {
                             $j1 :: r <join 0>
                             = GHC.Err.error
                                 @ 'GHC.Types.LiftedRep
                                 @ r
                                 $dIP4
                                   `cast`
                                 (Sym (GHC.Classes.N:IP[0]
                                           <"callStack">_N <GHC.Stack.Types.CallStack>_N))
                                 (GHC.Base.build
                                    @ GHC.Types.Char
                                    (\ @ b ->
                                     GHC.CString.unpackFoldrCString# @ b "column out of bounds"#))
                           } in
                           case GHC.Classes.ltInt c (GHC.Types.I# 0#) of wild3 {
                             GHC.Types.False
                             -> case GHC.Classes.geInt c (GHC.Types.I# dt1) of wild4 {
                                  GHC.Types.False
                                  -> case r1 of wild5 { GHC.Types.I# x ->
                                     case c of wild6 { GHC.Types.I# y ->
                                     k v (GHC.Types.I# (GHC.Prim.+# (GHC.Prim.*# x dt1) y)) } }
                                  GHC.Types.True -> $j1 }
                             GHC.Types.True -> $j1 }
                        GHC.Types.True -> $j }
                   GHC.Types.True -> $j } }) -}
3fb81a77c72e63ade6b927235e3e287b
  center :: Statistics.Matrix.Types.Matrix -> GHC.Types.Double
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(SSS(SLS)),1*U(U,U,U(U,A,U))>m,
     Unfolding: InlineRule (1, True, False)
                (\ (mat :: Statistics.Matrix.Types.Matrix) ->
                 case mat of wild { Statistics.Matrix.Types.Matrix dt dt1 ds ->
                 case ds
                        `cast`
                      (Data.Vector.Unboxed.Base.D:R:VectorDouble0[0] ; Data.Vector.Unboxed.Base.N:R:VectorDouble[0]) of wild1 { Data.Vector.Primitive.Vector dt2 dt3 dt4 ->
                 case GHC.Prim.indexDoubleArray#
                        dt4
                        (GHC.Prim.+#
                           dt2
                           (GHC.Prim.+#
                              (GHC.Prim.*# (GHC.Prim.quotInt# dt 2#) dt1)
                              (GHC.Prim.quotInt# dt1 2#))) of wild2 { DEFAULT ->
                 GHC.Types.D# wild2 } } }) -}
aafb86ba3a0ee0bc73c33ffc240f7b5d
  column ::
    Statistics.Matrix.Types.Matrix
    -> GHC.Types.Int -> Statistics.Matrix.Types.Vector
  {- Arity: 2, Strictness: <S(SLS),1*U(U,U,U(U,U,U))><S,1*U(U)>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ (ds :: Statistics.Matrix.Types.Matrix) (i :: GHC.Types.Int) ->
                 case ds of wild { Statistics.Matrix.Types.Matrix dt dt1 v ->
                 case (Data.Vector.Fusion.Bundle.Monadic.length
                         @ Data.Vector.Fusion.Util.Id
                         @ Data.Vector.Unboxed.Base.Vector
                         @ GHC.Types.Double
                         Data.Vector.Fusion.Util.$fMonadId
                         (Data.Vector.Fusion.Bundle.Monadic.fromVector
                            @ Data.Vector.Fusion.Util.Id
                            @ Data.Vector.Unboxed.Base.Vector
                            @ GHC.Types.Double
                            Data.Vector.Fusion.Util.$fMonadId
                            Data.Vector.Unboxed.Base.$fVectorVectorDouble
                            v))
                        `cast`
                      (Data.Vector.Fusion.Util.N:Id[0]
                           <GHC.Types.Int>_R) of v3 { GHC.Types.I# ipv ->
                 Data.Vector.Generic.new
                   @ Data.Vector.Unboxed.Base.Vector
                   @ GHC.Types.Double
                   Data.Vector.Unboxed.Base.$fVectorVectorDouble
                   (Data.Vector.Generic.New.unstream
                      @ Data.Vector.Unboxed.Base.Vector
                      @ GHC.Types.Double
                      Data.Vector.Unboxed.Base.$fVectorVectorDouble
                      (Data.Vector.Fusion.Bundle.Monadic.unbox
                         @ Data.Vector.Fusion.Util.Id
                         @ Data.Vector.Unboxed.Base.Vector
                         @ GHC.Types.Double
                         Data.Vector.Fusion.Util.$fMonadId
                         (Data.Vector.Fusion.Bundle.Monadic.mapM
                            @ Data.Vector.Fusion.Util.Id
                            @ GHC.Types.Int
                            @ (Data.Vector.Fusion.Util.Box GHC.Types.Double)
                            @ Data.Vector.Unboxed.Base.Vector
                            Data.Vector.Fusion.Util.$fMonadId
                            (\ (x :: GHC.Types.Int) ->
                             let {
                               file :: GHC.Base.String
                               = GHC.Base.build
                                   @ GHC.Types.Char
                                   (\ @ b ->
                                    GHC.CString.unpackFoldrCString# @ b "./Data/Vector/Generic.hs"#)
                             } in
                             case GHC.Classes.geInt x (GHC.Types.I# 0#) of wild1 {
                               GHC.Types.False
                               -> case x of wild2 { GHC.Types.I# i# ->
                                  Data.Vector.Internal.Check.checkError
                                    @ (Data.Vector.Fusion.Util.Box GHC.Types.Double)
                                    file
                                    (GHC.Types.I# 955#)
                                    Data.Vector.Internal.Check.Bounds
                                    (GHC.Base.build
                                       @ GHC.Types.Char
                                       (\ @ b ->
                                        GHC.CString.unpackFoldrCString# @ b "backpermute"#))
                                    (Data.Vector.Internal.Check.checkIndex_msg# i# ipv) }
                               GHC.Types.True
                               -> case GHC.Classes.ltInt x v3 of wild2 {
                                    GHC.Types.False
                                    -> case x of wild4 { GHC.Types.I# i# ->
                                       Data.Vector.Internal.Check.checkError
                                         @ (Data.Vector.Fusion.Util.Box GHC.Types.Double)
                                         file
                                         (GHC.Types.I# 955#)
                                         Data.Vector.Internal.Check.Bounds
                                         (GHC.Base.build
                                            @ GHC.Types.Char
                                            (\ @ b ->
                                             GHC.CString.unpackFoldrCString# @ b "backpermute"#))
                                         (Data.Vector.Internal.Check.checkIndex_msg# i# ipv) }
                                    GHC.Types.True
                                    -> case v `cast`
                                            (Data.Vector.Unboxed.Base.D:R:VectorDouble0[0] ; Data.Vector.Unboxed.Base.N:R:VectorDouble[0]) of wild4 { Data.Vector.Primitive.Vector dt2 dt3 dt4 ->
                                       case x of wild5 { GHC.Types.I# y ->
                                       case GHC.Prim.indexDoubleArray#
                                              dt4
                                              (GHC.Prim.+# dt2 y) of wild6 { DEFAULT ->
                                       Data.Vector.Fusion.Util.Box
                                         @ GHC.Types.Double
                                         (GHC.Types.D# wild6) } } } } })
                              `cast`
                            (<GHC.Types.Int>_R
                             ->_R Sym (Data.Vector.Fusion.Util.N:Id[0]
                                           <Data.Vector.Fusion.Util.Box GHC.Types.Double>_R))
                            (Data.Vector.Generic.stream
                               @ Data.Vector.Unboxed.Base.Vector
                               @ GHC.Types.Int
                               Data.Vector.Unboxed.Base.$fVectorVectorInt
                               (case i of v2 { GHC.Types.I# ipv1 ->
                                Data.Vector.Generic.new
                                  @ Data.Vector.Unboxed.Base.Vector
                                  @ GHC.Types.Int
                                  Data.Vector.Unboxed.Base.$fVectorVectorInt
                                  (Data.Vector.Generic.New.unstream
                                     @ Data.Vector.Unboxed.Base.Vector
                                     @ GHC.Types.Int
                                     Data.Vector.Unboxed.Base.$fVectorVectorInt
                                     (Data.Vector.Fusion.Bundle.Monadic.enumFromStepN
                                        @ GHC.Types.Int
                                        @ Data.Vector.Fusion.Util.Id
                                        @ Data.Vector.Unboxed.Base.Vector
                                        GHC.Num.$fNumInt
                                        Data.Vector.Fusion.Util.$fMonadId
                                        v2
                                        (GHC.Types.I# dt1)
                                        (GHC.Types.I# dt))) }))))) } }) -}
2efd4f7e604f75ceac668f4f84a1207e
  diag ::
    Statistics.Matrix.Types.Vector -> Statistics.Matrix.Types.Matrix
  {- Arity: 1, Strictness: <S(SSS),1*U(U,U,U)>m, Inline: [0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Statistics.Matrix.Types.Vector) ->
                 case w `cast`
                      (Data.Vector.Unboxed.Base.D:R:VectorDouble0[0] ; Data.Vector.Unboxed.Base.N:R:VectorDouble[0]) of ww { Data.Vector.Primitive.Vector ww1 ww2 ww3 ->
                 case Statistics.Matrix.$wdiag
                        ww1
                        ww2
                        ww3 of ww4 { (#,,#) ww5 ww6 ww7 ->
                 Statistics.Matrix.Types.Matrix ww5 ww6 ww7 } }) -}
096eac221e3001f7308c65b9f1140687
  diag1 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 0#) -}
cb757d3acc445304c54018891489319d
  diag2 ::
    GHC.Prim.Int#
    -> GHC.ST.ST
         s2
         (Data.Vector.Primitive.Mutable.MVector
            (Control.Monad.Primitive.PrimState (GHC.ST.ST s2))
            GHC.Types.Double)
  {- Arity: 1, Strictness: <B,U>x -}
88ce885ddaf785ee40f2ebb5fb99387f
  diag3 ::
    GHC.Prim.Int#
    -> GHC.ST.ST
         s2
         (Data.Vector.Primitive.Mutable.MVector
            (Control.Monad.Primitive.PrimState (GHC.ST.ST s2))
            GHC.Types.Double)
  {- Arity: 1, Strictness: <B,U>x -}
cfaa2ab356d35db1a5573b7a2ce0ab65
  diag4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("./Data/Vector/Generic.hs"#) -}
5921c743b0d55d17ade25b2e9df7b9d0
  diag5 ::
    GHC.Prim.Int#
    -> GHC.Prim.Int# -> GHC.Prim.Addr# -> GHC.Types.Double
  {- Arity: 3, Strictness: <B,U><B,U><B,U>x -}
8d4c2e73f034383992e2e6abbb036fdb
  dimension ::
    Statistics.Matrix.Types.Matrix -> (GHC.Types.Int, GHC.Types.Int)
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(U,U,A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Statistics.Matrix.Types.Matrix) ->
                 case ds of wild { Statistics.Matrix.Types.Matrix dt dt1 ds1 ->
                 (GHC.Types.I# dt, GHC.Types.I# dt1) }) -}
e857a49c1c0c745b9680d6941f831806
  fromColumns ::
    [Statistics.Matrix.Types.Vector] -> Statistics.Matrix.Types.Matrix
  {- Arity: 1, Strictness: <S,1*U>m,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: [Statistics.Matrix.Types.Vector]) ->
                 Statistics.Matrix.transpose (Statistics.Matrix.fromRows x)) -}
588e20519d381dddeb336b0072ac1a7b
  fromList ::
    GHC.Types.Int
    -> GHC.Types.Int
    -> [GHC.Types.Double]
    -> Statistics.Matrix.Types.Matrix
  {- Arity: 3, Strictness: <S,1*U(U)><S,1*U(U)><S,1*U>m, Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: GHC.Types.Int)
                   (w1 :: GHC.Types.Int)
                   (w2 :: [GHC.Types.Double]) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of ww2 { GHC.Types.I# ww3 ->
                 case GHC.Magic.runRW#
                        @ ('GHC.Types.TupleRep
                             '['GHC.Types.TupleRep '[], 'GHC.Types.LiftedRep])
                        @ (# GHC.Prim.State# GHC.Prim.RealWorld,
                             Data.Vector.Unboxed.Base.Vector GHC.Types.Double #)
                        (\ (s1 :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                         case GHC.Prim.newByteArray#
                                @ (Control.Monad.Primitive.PrimState
                                     (GHC.ST.ST GHC.Prim.RealWorld))
                                0#
                                s1
                                  `cast`
                                (GHC.Prim.State#
                                   (Sym (Control.Monad.Primitive.D:R:PrimStateST[0]
                                             <GHC.Prim.RealWorld>_N)))_R of ds1 { (#,#) ipv ipv1 ->
                         Statistics.Matrix.$wfoldlM_loop
                           GHC.Types.SPEC
                           0#
                           0#
                           ipv1
                             `cast`
                           (GHC.Prim.MutableByteArray#
                              (Control.Monad.Primitive.D:R:PrimStateST[0]
                                   <GHC.Prim.RealWorld>_N))_R
                           0#
                           w2
                           ipv
                             `cast`
                           (GHC.Prim.State#
                              (Control.Monad.Primitive.D:R:PrimStateST[0]
                                   <GHC.Prim.RealWorld>_N))_R }) of ds1 { (#,#) ipv1 ipv2 ->
                 case ipv2
                        `cast`
                      (Data.Vector.Unboxed.Base.D:R:VectorDouble0[0] ; Data.Vector.Unboxed.Base.N:R:VectorDouble[0]) of nt { Data.Vector.Primitive.Vector ipv ipv4 ipv5 ->
                 case GHC.Prim./=# (GHC.Prim.*# ww1 ww3) ipv4 of lwild {
                   DEFAULT
                   -> Statistics.Matrix.Types.Matrix
                        ww1
                        ww3
                        nt
                          `cast`
                        (Sym (Data.Vector.Unboxed.Base.N:R:VectorDouble[0]) ; Sym (Data.Vector.Unboxed.Base.D:R:VectorDouble0[0]))
                   1# -> Statistics.Matrix.fromRows3 } } } } }) -}
6b92e7f2fd6dc12dc0ca0c2600e01018
  fromRowLists ::
    [[GHC.Types.Double]] -> Statistics.Matrix.Types.Matrix
  {- Arity: 1, Strictness: <S,1*U>m,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: [[GHC.Types.Double]]) ->
                 Statistics.Matrix.fromRows
                   (GHC.Base.build
                      @ (Data.Vector.Unboxed.Base.Vector GHC.Types.Double)
                      (\ @ b1
                         (c :: Data.Vector.Unboxed.Base.Vector GHC.Types.Double
                               -> b1 -> b1)[OneShot]
                         (n :: b1)[OneShot] ->
                       GHC.Base.foldr
                         @ [GHC.Types.Double]
                         @ b1
                         (GHC.Base.mapFB
                            @ (Data.Vector.Unboxed.Base.Vector GHC.Types.Double)
                            @ b1
                            @ [GHC.Types.Double]
                            c
                            Statistics.Matrix.fromRowLists1)
                         n
                         x))) -}
0164d2c04abb8bc9d38cb013c498ff64
  fromRowLists1 ::
    [GHC.Types.Double]
    -> Data.Vector.Unboxed.Base.Vector GHC.Types.Double
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (x :: [GHC.Types.Double]) ->
                 case GHC.Magic.runRW#
                        @ ('GHC.Types.TupleRep
                             '['GHC.Types.TupleRep '[], 'GHC.Types.LiftedRep])
                        @ (# GHC.Prim.State# GHC.Prim.RealWorld,
                             Data.Vector.Unboxed.Base.Vector GHC.Types.Double #)
                        (\ (s1 :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                         case GHC.Prim.newByteArray#
                                @ (Control.Monad.Primitive.PrimState
                                     (GHC.ST.ST GHC.Prim.RealWorld))
                                0#
                                s1
                                  `cast`
                                (GHC.Prim.State#
                                   (Sym (Control.Monad.Primitive.D:R:PrimStateST[0]
                                             <GHC.Prim.RealWorld>_N)))_R of ds1 { (#,#) ipv ipv1 ->
                         Statistics.Matrix.$wfoldlM_loop1
                           GHC.Types.SPEC
                           0#
                           0#
                           ipv1
                             `cast`
                           (GHC.Prim.MutableByteArray#
                              (Control.Monad.Primitive.D:R:PrimStateST[0]
                                   <GHC.Prim.RealWorld>_N))_R
                           0#
                           x
                           ipv
                             `cast`
                           (GHC.Prim.State#
                              (Control.Monad.Primitive.D:R:PrimStateST[0]
                                   <GHC.Prim.RealWorld>_N))_R }) of ds1 { (#,#) ipv1 ipv2 ->
                 ipv2 }) -}
faecf7e4869c70e6f69fcef5dbc38e57
  fromRows ::
    [Statistics.Matrix.Types.Vector] -> Statistics.Matrix.Types.Matrix
  {- Arity: 1, Strictness: <S,1*U>m, Inline: [0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: [Statistics.Matrix.Types.Vector]) ->
                 case Statistics.Matrix.$wfromRows w of ww { (#,,#) ww1 ww2 ww3 ->
                 Statistics.Matrix.Types.Matrix ww1 ww2 ww3 }) -}
3f4223a4d81513f93d1da656ac40df52
  fromRows1 :: Statistics.Matrix.Types.Matrix
  {- Strictness: x -}
e563a3cf3ee2ef8ec975d16f4b644599
  fromRows2 :: Statistics.Matrix.Types.Matrix
  {- Strictness: x -}
6e8755de34e6558894048bb8dad1e820
  fromRows3 :: Statistics.Matrix.Types.Matrix
  {- Strictness: x -}
b0569b518c70bb70103e8abd6e9a86c7
  fromRows4 ::
    GHC.Prim.Int#
    -> GHC.ST.ST
         GHC.Prim.RealWorld
         (Data.Vector.Primitive.Mutable.MVector
            (Control.Monad.Primitive.PrimState (GHC.ST.ST GHC.Prim.RealWorld))
            GHC.Types.Double)
  {- Arity: 1, Strictness: <B,U>x -}
a8840954058748e143ca2cf075167965
  fromRows5 ::
    GHC.Prim.Int#
    -> GHC.ST.ST
         GHC.Prim.RealWorld
         (Data.Vector.Primitive.Mutable.MVector
            (Control.Monad.Primitive.PrimState (GHC.ST.ST GHC.Prim.RealWorld))
            GHC.Types.Double)
  {- Arity: 1, Strictness: <B,U>x -}
eabca19f331e0e1cc81cb778e70f96b4
  fromRows6 :: (GHC.Types.Int, [GHC.Types.Int])
  {- Strictness: x -}
ee6fc0aa7fc44a2b47b2f75ba26e9ce4
  fromRows7 ::
    Data.Vector.Unboxed.Base.Vector GHC.Types.Double
    -> Data.Vector.Fusion.Util.Id GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LSL),1*U(A,U,A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: Data.Vector.Unboxed.Base.Vector GHC.Types.Double) ->
                 case x `cast`
                      (Data.Vector.Unboxed.Base.D:R:VectorDouble0[0] ; Data.Vector.Unboxed.Base.N:R:VectorDouble[0]) of nt { Data.Vector.Primitive.Vector ipv ipv1 ipv2 ->
                 (GHC.Types.I# ipv1)
                   `cast`
                 (Sym (Data.Vector.Fusion.Util.N:Id[0] <GHC.Types.Int>_R)) }) -}
2feeb0133e96e8f9f93b96700a9dbc72
  fromRows8 :: Statistics.Matrix.Types.Matrix
  {- Strictness: x -}
966457df929f4a8d28f017051d8bb1f3
  fromVector ::
    GHC.Types.Int
    -> GHC.Types.Int
    -> Data.Vector.Unboxed.Base.Vector GHC.Types.Double
    -> Statistics.Matrix.Types.Matrix
  {- Arity: 3,
     Strictness: <S(S),1*U(U)><S(S),1*U(U)><S(LSL),1*U(U,U,U)>m,
     Unfolding: InlineRule (3, True, False)
                (\ (r :: GHC.Types.Int)
                   (c :: GHC.Types.Int)
                   (v :: Data.Vector.Unboxed.Base.Vector GHC.Types.Double) ->
                 case r of wild { GHC.Types.I# x ->
                 case c of wild1 { GHC.Types.I# y ->
                 case v `cast`
                      (Data.Vector.Unboxed.Base.D:R:VectorDouble0[0] ; Data.Vector.Unboxed.Base.N:R:VectorDouble[0]) of nt { Data.Vector.Primitive.Vector ipv ipv1 ipv2 ->
                 case GHC.Prim./=# (GHC.Prim.*# x y) ipv1 of lwild {
                   DEFAULT
                   -> Statistics.Matrix.Types.Matrix
                        x
                        y
                        (Data.Vector.Primitive.Vector @ GHC.Types.Double ipv ipv1 ipv2)
                          `cast`
                        (Sym (Data.Vector.Unboxed.Base.N:R:VectorDouble[0]) ; Sym (Data.Vector.Unboxed.Base.D:R:VectorDouble0[0]))
                   1# -> Statistics.Matrix.fromRows3 } } } }) -}
b37d0c63be73eef7647a7b4948ac42fc
  generate ::
    GHC.Types.Int
    -> GHC.Types.Int
    -> (GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Double)
    -> Statistics.Matrix.Types.Matrix
  {- Arity: 3,
     Strictness: <S(S),1*U(U)><S(S),1*U(U)><L,C(C1(U(U)))>m,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: GHC.Types.Int)
                   (w1 :: GHC.Types.Int)
                   (w2 :: GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Double) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of ww2 { GHC.Types.I# ww3 ->
                 case Statistics.Matrix.$wgenerate
                        ww1
                        ww3
                        w2 of ww4 { (#,,#) ww5 ww6 ww7 ->
                 Statistics.Matrix.Types.Matrix ww5 ww6 ww7 } } }) -}
1677de90fce3234acc24ceb41687dd37
  generate1 :: (GHC.Types.Int, GHC.Types.Int)
  {- Strictness: m,
     Unfolding: ((GHC.Real.overflowError @ GHC.Types.Int,
                  GHC.Real.$fIntegralInt1)) -}
6b6d141c106e22937f743988f64a4187
  generateSym ::
    GHC.Types.Int
    -> (GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Double)
    -> Statistics.Matrix.Types.Matrix
  {- Arity: 2, Strictness: <S(S),1*U(U)><L,C(C1(U(U)))>, Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: GHC.Types.Int)
                   (w1 :: GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Double) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 Statistics.Matrix.$wgenerateSym ww1 w1 }) -}
9330569f077f180a7bbfee840cec6cbd
  hasNaN :: Statistics.Matrix.Types.Matrix -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLS(SSS)),1*U(A,A,U(U,U,U))>,
     Unfolding: InlineRule (0, True, True)
                Statistics.Matrix.hasNaN1
                  `cast`
                (<Statistics.Matrix.Types.Matrix>_R
                 ->_R Data.Vector.Fusion.Util.N:Id[0] <GHC.Types.Bool>_R) -}
7b9478708bc1579e400418a58c52b944
  hasNaN1 ::
    Statistics.Matrix.Types.Matrix
    -> Data.Vector.Fusion.Util.Id GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLS(SSS)),1*U(A,A,U(U,U,U))>, Inline: [0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Statistics.Matrix.Types.Matrix) ->
                 case w of ww { Statistics.Matrix.Types.Matrix ww1 ww2 ww3 ->
                 case ww3
                        `cast`
                      (Data.Vector.Unboxed.Base.D:R:VectorDouble0[0] ; Data.Vector.Unboxed.Base.N:R:VectorDouble[0]) of ww4 { Data.Vector.Primitive.Vector ww5 ww6 ww7 ->
                 Statistics.Matrix.$whasNaN ww5 ww6 ww7 } }) -}
1d3d1ff0a198c6d951af3c714095c326
  ident :: GHC.Types.Int -> Statistics.Matrix.Types.Matrix
  {- Arity: 1, Strictness: <S(S),1*U(U)>m, Inline: [0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: GHC.Types.Int) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case Statistics.Matrix.$wident ww1 of ww2 { (#,,#) ww3 ww4 ww5 ->
                 Statistics.Matrix.Types.Matrix ww3 ww4 ww5 } }) -}
f4644846e88fa1b28908a6ebf5ed8b3f
  map ::
    (GHC.Types.Double -> GHC.Types.Double)
    -> Statistics.Matrix.Types.Matrix -> Statistics.Matrix.Types.Matrix
  {- Arity: 2,
     Strictness: <L,C(U(U))><S(SSS(SSS)),1*U(U,U,U(U,U,U))>m,
     Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: GHC.Types.Double -> GHC.Types.Double)
                   (w1 :: Statistics.Matrix.Types.Matrix) ->
                 case w1 of ww { Statistics.Matrix.Types.Matrix ww1 ww2 ww3 ->
                 case ww3
                        `cast`
                      (Data.Vector.Unboxed.Base.D:R:VectorDouble0[0] ; Data.Vector.Unboxed.Base.N:R:VectorDouble[0]) of ww4 { Data.Vector.Primitive.Vector ww5 ww6 ww7 ->
                 case Statistics.Matrix.$wmap
                        w
                        ww1
                        ww2
                        ww5
                        ww6
                        ww7 of ww8 { (#,,#) ww9 ww10 ww11 ->
                 Statistics.Matrix.Types.Matrix ww9 ww10 ww11 } } }) -}
110aa4282eb0a5c4a29097c045c5574d
  multiply ::
    Statistics.Matrix.Types.Matrix
    -> Statistics.Matrix.Types.Matrix -> Statistics.Matrix.Types.Matrix
  {- Arity: 2,
     Strictness: <S(SSS(SSS)),1*U(U,U,U(U,U,U))><S(SSS(SSS)),1*U(U,U,U(U,U,U))>m,
     Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Statistics.Matrix.Types.Matrix)
                   (w1 :: Statistics.Matrix.Types.Matrix) ->
                 case w of ww { Statistics.Matrix.Types.Matrix ww1 ww2 ww3 ->
                 case ww3
                        `cast`
                      (Data.Vector.Unboxed.Base.D:R:VectorDouble0[0] ; Data.Vector.Unboxed.Base.N:R:VectorDouble[0]) of ww4 { Data.Vector.Primitive.Vector ww5 ww6 ww7 ->
                 case w1 of ww8 { Statistics.Matrix.Types.Matrix ww9 ww10 ww11 ->
                 case ww11
                        `cast`
                      (Data.Vector.Unboxed.Base.D:R:VectorDouble0[0] ; Data.Vector.Unboxed.Base.N:R:VectorDouble[0]) of ww12 { Data.Vector.Primitive.Vector ww13 ww14 ww15 ->
                 case Statistics.Matrix.$wmultiply
                        ww1
                        ww2
                        ww5
                        ww6
                        ww7
                        ww9
                        ww10
                        ww13
                        ww14
                        ww15 of ww16 { (#,,#) ww17 ww18 ww19 ->
                 Statistics.Matrix.Types.Matrix ww17 ww18 ww19 } } } } }) -}
a85443b1013e7fdce37bbbfab2379750
  multiplyV ::
    Statistics.Matrix.Types.Matrix
    -> Statistics.Matrix.Types.Vector -> Statistics.Matrix.Types.Vector
  {- Arity: 2,
     Strictness: <S(SSS(SSS)),1*U(U,U,U(U,U,U))><S(SSS),1*U(U,U,U)>,
     Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Statistics.Matrix.Types.Matrix)
                   (w1 :: Statistics.Matrix.Types.Vector) ->
                 case w of ww { Statistics.Matrix.Types.Matrix ww1 ww2 ww3 ->
                 case ww3
                        `cast`
                      (Data.Vector.Unboxed.Base.D:R:VectorDouble0[0] ; Data.Vector.Unboxed.Base.N:R:VectorDouble[0]) of ww4 { Data.Vector.Primitive.Vector ww5 ww6 ww7 ->
                 case w1
                        `cast`
                      (Data.Vector.Unboxed.Base.D:R:VectorDouble0[0] ; Data.Vector.Unboxed.Base.N:R:VectorDouble[0]) of ww8 { Data.Vector.Primitive.Vector ww9 ww10 ww11 ->
                 Statistics.Matrix.$wmultiplyV
                   ww1
                   ww2
                   ww5
                   ww6
                   ww7
                   ww9
                   ww10
                   ww11 } } }) -}
1145890bae706303d6b7655401a1e3e0
  multiplyV1 ::
    GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> Data.Vector.Unboxed.Base.Vector GHC.Types.Double
  {- Arity: 3, Strictness: <B,U><B,U><B,U>x -}
7c9b3aeff38ec909cb530eb1339624ae
  norm :: Statistics.Matrix.Types.Vector -> GHC.Types.Double
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SSS),1*U(U,U,U)>m,
     Inline: [0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Statistics.Matrix.Types.Vector) ->
                 case w `cast`
                      (Data.Vector.Unboxed.Base.D:R:VectorDouble0[0] ; Data.Vector.Unboxed.Base.N:R:VectorDouble[0]) of ww { Data.Vector.Primitive.Vector ww1 ww2 ww3 ->
                 case Statistics.Matrix.$wnorm ww1 ww2 ww3 of ww4 { DEFAULT ->
                 GHC.Types.D# ww4 } }) -}
42729dade982740e13001e0934b7618b
  power ::
    Statistics.Matrix.Types.Matrix
    -> GHC.Types.Int -> Statistics.Matrix.Types.Matrix
  {- Arity: 2,
     Strictness: <S(SSS),1*U(U,U,U(U,U,U))><S(S),1*U(1*U)>m,
     Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Statistics.Matrix.Types.Matrix) (w1 :: GHC.Types.Int) ->
                 case w of ww { Statistics.Matrix.Types.Matrix ww1 ww2 ww3 ->
                 case w1 of ww4 { GHC.Types.I# ww5 ->
                 case Statistics.Matrix.$wpower
                        ww1
                        ww2
                        ww3
                        ww5 of ww6 { (#,,#) ww7 ww8 ww9 ->
                 Statistics.Matrix.Types.Matrix ww7 ww8 ww9 } } }) -}
543b8434c02a62db7817bc4c3cfbf02d
  row ::
    Statistics.Matrix.Types.Matrix
    -> GHC.Types.Int -> Statistics.Matrix.Types.Vector
  {- Arity: 2,
     Strictness: <S(LSS(SSS)),1*U(A,U,U(U,U,U))><S(S),1*U(U)>m,
     Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Statistics.Matrix.Types.Matrix) (w1 :: GHC.Types.Int) ->
                 case w of ww { Statistics.Matrix.Types.Matrix ww1 ww2 ww3 ->
                 case ww3
                        `cast`
                      (Data.Vector.Unboxed.Base.D:R:VectorDouble0[0] ; Data.Vector.Unboxed.Base.N:R:VectorDouble[0]) of ww4 { Data.Vector.Primitive.Vector ww5 ww6 ww7 ->
                 case w1 of ww8 { GHC.Types.I# ww9 ->
                 case Statistics.Matrix.$wrow
                        ww2
                        ww5
                        ww6
                        ww7
                        ww9 of ww10 { (#,,#) ww11 ww12 ww13 ->
                 (Data.Vector.Primitive.Vector @ GHC.Types.Double ww11 ww12 ww13)
                   `cast`
                 (Sym (Data.Vector.Unboxed.Base.N:R:VectorDouble[0]) ; Sym (Data.Vector.Unboxed.Base.D:R:VectorDouble0[0])) } } } }) -}
ff130f2b3a83771b83596f69406860cc
  toColumns ::
    Statistics.Matrix.Types.Matrix -> [Statistics.Matrix.Types.Vector]
  {- Arity: 1, Strictness: <S(SSS(SLS)),1*U(U,U,U(U,A,U))>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: Statistics.Matrix.Types.Matrix) ->
                 Statistics.Matrix.toRows (Statistics.Matrix.transpose x)) -}
3d081f3742b7629589d5654c5435e9b8
  toList :: Statistics.Matrix.Types.Matrix -> [GHC.Types.Double]
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLS(SSS)),1*U(A,A,U(U,U,U))>, Inline: [0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Statistics.Matrix.Types.Matrix) ->
                 case w of ww { Statistics.Matrix.Types.Matrix ww1 ww2 ww3 ->
                 case ww3
                        `cast`
                      (Data.Vector.Unboxed.Base.D:R:VectorDouble0[0] ; Data.Vector.Unboxed.Base.N:R:VectorDouble[0]) of ww4 { Data.Vector.Primitive.Vector ww5 ww6 ww7 ->
                 Statistics.Matrix.$wtoList ww5 ww6 ww7 } }) -}
9b73140fb7141fded4d6587d77e7ed18
  toRowLists ::
    Statistics.Matrix.Types.Matrix -> [[GHC.Types.Double]]
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LSS(SSS)),1*U(A,U,U(U,U,U))>, Inline: [0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Statistics.Matrix.Types.Matrix) ->
                 case w of ww { Statistics.Matrix.Types.Matrix ww1 ww2 ww3 ->
                 case ww3
                        `cast`
                      (Data.Vector.Unboxed.Base.D:R:VectorDouble0[0] ; Data.Vector.Unboxed.Base.N:R:VectorDouble[0]) of ww4 { Data.Vector.Primitive.Vector ww5 ww6 ww7 ->
                 Statistics.Matrix.$wtoRowLists ww2 ww5 ww6 ww7 } }) -}
4950c5dbe4aa310fbd3953ae3cfdea0f
  toRows ::
    Statistics.Matrix.Types.Matrix -> [Statistics.Matrix.Types.Vector]
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LSS(SSS)),1*U(A,U,U(U,1*U,U))>, Inline: [0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Statistics.Matrix.Types.Matrix) ->
                 case w of ww { Statistics.Matrix.Types.Matrix ww1 ww2 ww3 ->
                 case ww3
                        `cast`
                      (Data.Vector.Unboxed.Base.D:R:VectorDouble0[0] ; Data.Vector.Unboxed.Base.N:R:VectorDouble[0]) of ww4 { Data.Vector.Primitive.Vector ww5 ww6 ww7 ->
                 Statistics.Matrix.$wtoRows ww2 ww5 ww6 ww7 } }) -}
86951516c052a0dd78fb41fadc343231
  toVector ::
    Statistics.Matrix.Types.Matrix
    -> Data.Vector.Unboxed.Base.Vector GHC.Types.Double
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LLS),1*U(A,A,U(U,U,U))>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Statistics.Matrix.Types.Matrix) ->
                 case ds of wild { Statistics.Matrix.Types.Matrix dt dt1 v ->
                 v }) -}
1e190ea30545baeb80a0a134ba0a0647
  transpose ::
    Statistics.Matrix.Types.Matrix -> Statistics.Matrix.Types.Matrix
  {- Arity: 1, Strictness: <S(SSS(SLS)),1*U(U,U,U(U,A,U))>m,
     Inline: [0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Statistics.Matrix.Types.Matrix) ->
                 case w of ww { Statistics.Matrix.Types.Matrix ww1 ww2 ww3 ->
                 case ww3
                        `cast`
                      (Data.Vector.Unboxed.Base.D:R:VectorDouble0[0] ; Data.Vector.Unboxed.Base.N:R:VectorDouble[0]) of ww4 { Data.Vector.Primitive.Vector ww5 ww6 ww7 ->
                 case Statistics.Matrix.$wtranspose
                        ww1
                        ww2
                        ww5
                        ww7 of ww8 { (#,,#) ww9 ww10 ww11 ->
                 Statistics.Matrix.Types.Matrix ww9 ww10 ww11 } } }) -}
47d0646b3a79a472562ee361b09bc04d
  unsafeBounds ::
    (Statistics.Matrix.Types.Vector -> GHC.Types.Int -> r)
    -> Statistics.Matrix.Types.Matrix
    -> GHC.Types.Int
    -> GHC.Types.Int
    -> r
  {- Arity: 4, HasNoCafRefs,
     Strictness: <C(C(S)),1*C1(C1(U))><S(LLS),1*U(A,U,U)><S,1*U(U)><S,1*U(U)>,
     Inline: (sat-args=4),
     Unfolding: InlineRule (4, False, False)
                (\ @ r
                   (k :: Statistics.Matrix.Types.Vector -> GHC.Types.Int -> r)
                   (ds :: Statistics.Matrix.Types.Matrix)
                   (r1 :: GHC.Types.Int)
                   (c :: GHC.Types.Int) ->
                 case ds of wild { Statistics.Matrix.Types.Matrix dt dt1 v ->
                 case r1 of wild1 { GHC.Types.I# x ->
                 case c of wild2 { GHC.Types.I# y ->
                 k v (GHC.Types.I# (GHC.Prim.+# (GHC.Prim.*# x dt1) y)) } } }) -}
a31af56318ef2c7f5759adb8cca5edf1
  unsafeIndex ::
    Statistics.Matrix.Types.Matrix
    -> GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Double
  {- Arity: 3, HasNoCafRefs,
     Unfolding: (Statistics.Matrix.unsafeBounds
                   @ GHC.Types.Double
                   Statistics.Matrix.$sunsafeIndex) -}
"SPEC/Statistics.Matrix unsafeIndex @ Vector @ Double" [orphan] [1] forall ($dVector :: Data.Vector.Generic.Base.Vector
                                                                                          Data.Vector.Unboxed.Base.Vector
                                                                                          GHC.Types.Double)
  Data.Vector.Generic.unsafeIndex @ Data.Vector.Unboxed.Base.Vector
                                  @ GHC.Types.Double
                                  $dVector
  = Statistics.Matrix.$sunsafeIndex
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: none
require own pkg trusted: False

