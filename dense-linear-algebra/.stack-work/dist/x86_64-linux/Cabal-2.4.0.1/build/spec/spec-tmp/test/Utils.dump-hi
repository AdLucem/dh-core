
==================== FINAL INTERFACE ====================
2019-02-27 19:48:23.107046994 UTC

interface main:Utils 8063
  interface hash: e3b5a882059e3f8c0165ceacd180985c
  ABI hash: 3259016111fa8079afcd0aacee713e55
  export-list hash: 542fc4e281cce90adcb7a18c0e5e2a0b
  orphan hash: 13c0be58a5d646cbcb3d662346e9bdb6
  flag hash: 6e53648eade1ec3ffa724212f94d04d6
  opt_hash: 6faf2de08de32d19db9870899d88e59a
  hpc_hash: 93b885adfe0da089cdf634904fd59f71
  plugin_hash: ad164012d6b1e14942349d58b1132007
  sig of: Nothing
  used TH splices: False
  where
exports:
  Utils.det
  Utils.getRest
  Utils.hasLeadingZeros
  Utils.isEqual
  Utils.isFloatZero
  Utils.isInvertible
  Utils.isOrtho
  Utils.isRowFromTriMatrix
  Utils.isUpperTri
  Utils.leaveElement
  Utils.makeAbs
  Utils.makeDecimal
  Utils.upperTriHelper
module dependencies: Fixtures
package dependencies: Decimal-0.5.1 array-0.5.3.0 base-4.12.0.0
                      deepseq-1.4.4.0 dense-linear-algebra-0.1.0.0 ghc-boot-th-8.6.3
                      ghc-prim-0.5.3 integer-gmp-1.0.2.0 math-functions-0.3.1.0
                      pretty-1.1.3.6 primitive-0.6.4.0 template-haskell-2.14.0.0
                      transformers-0.5.5.0 vector-0.12.0.2 vector-th-unbox-0.2.1.6
orphans: vector-0.12.0.2:Data.Vector.Unboxed
         vector-0.12.0.2:Data.Vector.Fusion.Bundle
         transformers-0.5.5.0:Control.Monad.Trans.Error
         base-4.12.0.0:GHC.Float base-4.12.0.0:GHC.Base
family instance modules: base-4.12.0.0:Control.Applicative
                         base-4.12.0.0:Data.Complex base-4.12.0.0:Data.Functor.Compose
                         base-4.12.0.0:Data.Functor.Const
                         base-4.12.0.0:Data.Functor.Identity
                         base-4.12.0.0:Data.Functor.Product base-4.12.0.0:Data.Functor.Sum
                         base-4.12.0.0:Data.Monoid base-4.12.0.0:Data.Semigroup
                         base-4.12.0.0:Data.Semigroup.Internal base-4.12.0.0:Data.Version
                         base-4.12.0.0:Data.Void base-4.12.0.0:GHC.Exts
                         base-4.12.0.0:GHC.Generics base-4.12.0.0:GHC.IO.Exception
                         ghc-boot-th-8.6.3:GHC.ForeignSrcLang.Type
                         ghc-boot-th-8.6.3:GHC.LanguageExtensions.Type
                         math-functions-0.3.1.0:Numeric.Sum
                         pretty-1.1.3.6:Text.PrettyPrint.Annotated.HughesPJ
                         pretty-1.1.3.6:Text.PrettyPrint.HughesPJ
                         primitive-0.6.4.0:Control.Monad.Primitive
                         primitive-0.6.4.0:Data.Primitive.Array
                         primitive-0.6.4.0:Data.Primitive.ByteArray
                         primitive-0.6.4.0:Data.Primitive.PrimArray
                         primitive-0.6.4.0:Data.Primitive.SmallArray
                         primitive-0.6.4.0:Data.Primitive.UnliftedArray
                         template-haskell-2.14.0.0:Language.Haskell.TH.Syntax
                         vector-0.12.0.2:Data.Vector vector-0.12.0.2:Data.Vector.Primitive
                         vector-0.12.0.2:Data.Vector.Unboxed
                         vector-0.12.0.2:Data.Vector.Unboxed.Base
import  -/  Decimal-0.5.1:Data.Decimal f570d2a17304ba1426c63f1c994f196f
import  -/  base-4.12.0.0:Data.Foldable 00188ddf89c975fee76bdfad479443c1
import  -/  base-4.12.0.0:Data.Tuple c92a835d04b6c075a7031d4e28e53c71
import  -/  base-4.12.0.0:GHC.Base cc906f98291a1b830546e99a96674547
import  -/  base-4.12.0.0:GHC.List 734a72beb76d276fb4a0ba2689a5711f
import  -/  base-4.12.0.0:GHC.Num 847723f2584d989dac1eada133ac3fb8
import  -/  base-4.12.0.0:GHC.Real f7dad82c1d43d80823865d3e6c6636e0
import  -/  base-4.12.0.0:GHC.Word 2f81835517a554ac93a9eb8154dc67ce
import  -/  base-4.12.0.0:Prelude 5c01365ec01f83bd405ac01cbb9a8d76
import  -/  dense-linear-algebra-0.1.0.0:Statistics.Matrix 139ad343f7aee20177eb49ca95eab3d3
import  -/  dense-linear-algebra-0.1.0.0:Statistics.Matrix.Algorithms a1bea6e15f3ddee29402e5430634a9d2
import  -/  dense-linear-algebra-0.1.0.0:Statistics.Matrix.Function 0d2f9f32ad7ae03fa8f250e2f0be0b5c
import  -/  dense-linear-algebra-0.1.0.0:Statistics.Matrix.Mutable 4e30ab6a7bd9ce223e9906bd793dbb85
import  -/  dense-linear-algebra-0.1.0.0:Statistics.Matrix.Types e85952c26980c1752607abe8d259c6cf
import  -/  ghc-prim-0.5.3:GHC.Classes e0d9c979f6368701f34fa421754d2cce
import  -/  Fixtures 142c34dfffe34824ef4c26c9a5746fbd
  exports: a69bdcabee6fd1e543fcaca09351501f
  matId 2e6516aa08142fc0c0888f6927ecc207
import  -/  vector-0.12.0.2:Data.Vector.Unboxed 3ec9008297a7b27b6fe569e181327338
ce500427e1e5f4750dd41c42990c1c0f
  $s$fEqDecimalRaw ::
    GHC.Classes.Eq (Data.Decimal.DecimalRaw GHC.Integer.Type.Integer)
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (Data.Decimal.DecimalRaw GHC.Integer.Type.Integer)
                  (Data.Decimal.$fEqDecimalRaw_$c==
                     @ GHC.Integer.Type.Integer
                     GHC.Real.$fIntegralInteger)
                  Utils.$s$fEqDecimalRaw_$s$fEqDecimalRaw_$c/= -}
365f73571ffa5a4057e067cff9e9de77
  $s$fEqDecimalRaw_$s$fEqDecimalRaw_$c/= ::
    Data.Decimal.DecimalRaw GHC.Integer.Type.Integer
    -> Data.Decimal.DecimalRaw GHC.Integer.Type.Integer
    -> GHC.Types.Bool
  {- Arity: 2, Strictness: <S(SS),1*U(U,U)><S(SS),1*U(U,U)>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ (x :: Data.Decimal.DecimalRaw GHC.Integer.Type.Integer)
                   (y :: Data.Decimal.DecimalRaw GHC.Integer.Type.Integer) ->
                 case Data.Decimal.$fEqDecimalRaw_$c==
                        @ GHC.Integer.Type.Integer
                        GHC.Real.$fIntegralInteger
                        x
                        y of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
4213174633b87a1f1f98d428f01a2c1b
  $s$fEq[] ::
    GHC.Classes.Eq [Data.Decimal.DecimalRaw GHC.Integer.Type.Integer]
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ [Data.Decimal.DecimalRaw GHC.Integer.Type.Integer]
                  (GHC.Classes.$fEq[]_$c==
                     @ (Data.Decimal.DecimalRaw GHC.Integer.Type.Integer)
                     Utils.$s$fEqDecimalRaw)
                  Utils.$s$fEq[]_$s$fEq[]_$c/= -}
8800fc9e56861802d89d3873d1bcd0f4
  $s$fEq[]_$s$fEq[]_$c/= ::
    [Data.Decimal.DecimalRaw GHC.Integer.Type.Integer]
    -> [Data.Decimal.DecimalRaw GHC.Integer.Type.Integer]
    -> GHC.Types.Bool
  {- Arity: 2, Strictness: <S,1*U><S,1*U>, Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ (x :: [Data.Decimal.DecimalRaw GHC.Integer.Type.Integer])
                   (y :: [Data.Decimal.DecimalRaw GHC.Integer.Type.Integer]) ->
                 case GHC.Classes.$fEq[]_$c==
                        @ (Data.Decimal.DecimalRaw GHC.Integer.Type.Integer)
                        Utils.$s$fEqDecimalRaw
                        x
                        y of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
a12658d0a681752c98cb3fc6d3fc5852
  $s^1 :: GHC.Types.Double
  {- Strictness: x -}
6e4cfbbe250611482ac08c6d558f4dce
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module Utils.$trModule3 Utils.$trModule1) -}
6ea2ae0a946ba28d3e9a92ae079dc36e
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Utils.$trModule2) -}
c81636fcbf58b412e558c29d269dd105
  $trModule2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Utils"#) -}
48e9693c199df8b405168bfddb9c283b
  $trModule3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Utils.$trModule4) -}
be56da26131302c822ff452d3bc5ec6f
  $trModule4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("main"#) -}
d0605579bb34dcd3090af002be911d84
  $wf :: GHC.Prim.Double# -> GHC.Prim.Int# -> GHC.Prim.Double#
  {- Arity: 2, HasNoCafRefs, Strictness: <S,U><S,U>, Inline: [2] -}
189c7737a76f07e50d3270b62648e711
  $whasLeadingZeros ::
    GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Prim.ByteArray#
    -> Data.Vector.Fusion.Util.Id GHC.Types.Bool
  {- Arity: 4, HasNoCafRefs, Strictness: <S,U><L,U><S,U><L,U>,
     Inline: [2],
     Unfolding: (\ (ww :: GHC.Prim.Int#)
                   (ww1 :: GHC.Prim.Int#)
                   (ww2 :: GHC.Prim.Int#)
                   (ww3 :: GHC.Prim.ByteArray#) ->
                 let {
                   $w$j :: GHC.Prim.Int# -> Data.Vector.Fusion.Util.Id GHC.Types.Bool
                     <join 1> {- Arity: 1, Strictness: <S,U>, Inline: [2] -}
                   = \ (w :: GHC.Prim.Int#)[OneShot] ->
                     let {
                       $j :: GHC.Prim.Int# -> Data.Vector.Fusion.Util.Id GHC.Types.Bool
                         <join 1> {- Arity: 1, Strictness: <S,U> -}
                       = \ (dt :: GHC.Prim.Int#)[OneShot] ->
                         letrec {
                           $wfoldlM_loop :: GHC.Types.SPEC
                                            -> GHC.Types.Bool
                                            -> GHC.Prim.Int#
                                            -> Data.Vector.Fusion.Util.Id GHC.Types.Bool
                             <join 3> {- Arity: 3, Strictness: <S,1*U><S,1*U><S,U>,
                                         Inline: [2] -}
                           = \ (w1 :: GHC.Types.SPEC)
                               (w2 :: GHC.Types.Bool)
                               (ww4 :: GHC.Prim.Int#) ->
                             case w1 of ds5 { DEFAULT ->
                             case GHC.Prim.>=# ww4 dt of lwild {
                               DEFAULT
                               -> case GHC.Prim.indexDoubleArray#
                                         ww3
                                         (GHC.Prim.+# ww1 ww4) of wild2 { DEFAULT ->
                                  case w2 of wild {
                                    GHC.Types.False
                                    -> $wfoldlM_loop
                                         GHC.Types.SPEC
                                         GHC.Types.False
                                         (GHC.Prim.+# ww4 1#)
                                    GHC.Types.True
                                    -> $wfoldlM_loop
                                         GHC.Types.SPEC
                                         (GHC.Prim.tagToEnum#
                                            @ GHC.Types.Bool
                                            (GHC.Prim.==## wild2 0.0##))
                                         (GHC.Prim.+# ww4 1#) } }
                               1#
                               -> w2
                                    `cast`
                                  (Sym (Data.Vector.Fusion.Util.N:Id[0] <GHC.Types.Bool>_R)) } }
                         } in
                         $wfoldlM_loop GHC.Types.SPEC GHC.Types.True 0#
                     } in
                     case GHC.Prim.<=# w ww2 of lwild { DEFAULT -> $j ww2 1# -> $j w }
                 } in
                 case GHC.Prim.<=# ww 0# of lwild {
                   DEFAULT -> $w$j ww 1# -> $w$j 0# }) -}
8c9130c7fbf6cafc12b3b26d44bc9e1f
  $wisOrtho ::
    GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Prim.ByteArray#
    -> GHC.Types.Bool
  {- Arity: 5, Strictness: <S,U><S,U><S,U><S,U><S,U>, Inline: [2],
     Unfolding: (\ (ww :: GHC.Prim.Int#)
                   (ww1 :: GHC.Prim.Int#)
                   (ww2 :: GHC.Prim.Int#)
                   (ww3 :: GHC.Prim.Int#)
                   (ww4 :: GHC.Prim.ByteArray#) ->
                 case Statistics.Matrix.$wtranspose
                        ww
                        ww1
                        ww2
                        ww4 of ww8 { (#,,#) ww9 ww10 ww11 ->
                 case ww11
                        `cast`
                      (Data.Vector.Unboxed.Base.D:R:VectorDouble0[0] ; Data.Vector.Unboxed.Base.N:R:VectorDouble[0]) of ww12 { Data.Vector.Primitive.Vector ww13 ww14 ww15 ->
                 case Statistics.Matrix.$wmultiply
                        ww
                        ww1
                        ww2
                        ww3
                        ww4
                        ww9
                        ww10
                        ww13
                        ww14
                        ww15 of ww16 { (#,,#) ww17 ww18 ww19 ->
                 case ww19
                        `cast`
                      (Data.Vector.Unboxed.Base.D:R:VectorDouble0[0] ; Data.Vector.Unboxed.Base.N:R:VectorDouble[0]) of ww5 { Data.Vector.Primitive.Vector ww6 ww7 ww23 ->
                 GHC.Classes.$fEq[]_$c==
                   @ [Data.Decimal.Decimal]
                   Utils.$s$fEq[]
                   (Utils.$wmakeDecimal Utils.isOrtho_prec ww18 ww6 ww7 ww23)
                   Utils.isOrtho1 } } } }) -}
6042725707e9f4a4d1610150fbc15d65
  $wisRowFromTriMatrix ::
    GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Prim.ByteArray#
    -> GHC.Prim.Int#
    -> Data.Vector.Fusion.Util.Id GHC.Types.Bool
  {- Arity: 5, Strictness: <S,U><S,U><S,U><S,U><S,U>, Inline: [2],
     Unfolding: (\ (ww :: GHC.Prim.Int#)
                   (ww1 :: GHC.Prim.Int#)
                   (ww2 :: GHC.Prim.Int#)
                   (ww3 :: GHC.Prim.ByteArray#)
                   (ww4 :: GHC.Prim.Int#) ->
                 case Statistics.Matrix.$wrow
                        ww
                        ww1
                        ww2
                        ww3
                        ww4 of ww10 { (#,,#) ww11 ww12 ww13 ->
                 Utils.$whasLeadingZeros ww4 ww11 ww12 ww13 }) -}
cb6a799062884b8317a51d3913495b91
  $wleaveElement :: GHC.Types.Int -> [a] -> [a]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(1*U)><S,1*U>,
     Inline: [2] -}
ec8d2a21bc833bd62beeafd9fc2b8f19
  $wmakeAbs ::
    GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Prim.ByteArray#
    -> (# GHC.Prim.Int#, GHC.Prim.Int#,
          Statistics.Matrix.Types.Vector #)
  {- Arity: 5, Strictness: <L,U><L,U><L,U><S,U><L,U>, Inline: [2],
     Unfolding: (\ (ww :: GHC.Prim.Int#)
                   (ww1 :: GHC.Prim.Int#)
                   (ww2 :: GHC.Prim.Int#)
                   (ww3 :: GHC.Prim.Int#)
                   (ww4 :: GHC.Prim.ByteArray#) ->
                 case GHC.Magic.runRW#
                        @ ('GHC.Types.TupleRep
                             '[ 'GHC.Types.TupleRep '[], 'GHC.Types.LiftedRep])
                        @ (# GHC.Prim.State# GHC.Prim.RealWorld,
                             Data.Vector.Unboxed.Base.Vector GHC.Types.Double #)
                        (\ (s1 :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                         case GHC.Prim.<# ww3 0# of lwild {
                           DEFAULT
                           -> case GHC.Prim.># ww3 1152921504606846975# of lwild1 {
                                DEFAULT
                                -> case GHC.Prim.newByteArray#
                                          @ (Control.Monad.Primitive.PrimState
                                               (GHC.ST.ST GHC.Prim.RealWorld))
                                          (GHC.Prim.*# ww3 8#)
                                          s1
                                            `cast`
                                          (GHC.Prim.State#
                                             (Sym (Control.Monad.Primitive.D:R:PrimStateST[0]
                                                       <GHC.Prim.RealWorld>_N)))_R of ds1 { (#,#) ipv ipv1 ->
                                   let {
                                     exit :: GHC.Prim.Int#
                                             -> GHC.Prim.State# GHC.Prim.RealWorld
                                             -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                                   Data.Vector.Unboxed.Base.Vector
                                                     GHC.Types.Double #)
                                       <join 2> {- Arity: 2, Strictness: <L,U><S,U> -}
                                     = \ (ww5 :: GHC.Prim.Int#)[OneShot]
                                         (w1 :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                                       case GHC.Prim.unsafeFreezeByteArray#
                                              @ (Control.Monad.Primitive.PrimState
                                                   (GHC.ST.ST GHC.Prim.RealWorld))
                                              ipv1
                                              w1
                                                `cast`
                                              (GHC.Prim.State#
                                                 (Sym (Control.Monad.Primitive.D:R:PrimStateST[0]
                                                           <GHC.Prim.RealWorld>_N)))_R of ds2 { (#,#) ipv2 ipv3 ->
                                       (# ipv2
                                            `cast`
                                          (GHC.Prim.State#
                                             (Control.Monad.Primitive.D:R:PrimStateST[0]
                                                  <GHC.Prim.RealWorld>_N))_R,
                                          (Data.Vector.Primitive.Vector
                                             @ GHC.Types.Double
                                             0#
                                             ww5
                                             ipv3)
                                            `cast`
                                          (Sym (Data.Vector.Unboxed.Base.N:R:VectorDouble[0]) ; Sym (Data.Vector.Unboxed.Base.D:R:VectorDouble0[0])) #) }
                                   } in
                                   letrec {
                                     $wfoldlM'_loop :: GHC.Types.SPEC
                                                       -> GHC.Prim.Int#
                                                       -> GHC.Prim.Int#
                                                       -> GHC.Prim.State# GHC.Prim.RealWorld
                                                       -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                                             Data.Vector.Unboxed.Base.Vector
                                                               GHC.Types.Double #)
                                       <join 4> {- Arity: 4, Strictness: <S,1*U><S,U><S,U><S,U>,
                                                   Inline: [2] -}
                                     = \ (w1 :: GHC.Types.SPEC)
                                         (ww5 :: GHC.Prim.Int#)
                                         (ww6 :: GHC.Prim.Int#)
                                         (w2 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                                       case w1 of ds5 { DEFAULT ->
                                       case GHC.Prim.>=# ww6 ww3 of lwild2 {
                                         DEFAULT
                                         -> case GHC.Prim.indexDoubleArray#
                                                   ww4
                                                   (GHC.Prim.+# ww2 ww6) of wild2 { DEFAULT ->
                                            case GHC.Prim.writeDoubleArray#
                                                   @ (Control.Monad.Primitive.PrimState
                                                        (GHC.ST.ST GHC.Prim.RealWorld))
                                                   ipv1
                                                   ww5
                                                   (GHC.Prim.fabsDouble# wild2)
                                                   w2
                                                     `cast`
                                                   (GHC.Prim.State#
                                                      (Sym (Control.Monad.Primitive.D:R:PrimStateST[0]
                                                                <GHC.Prim.RealWorld>_N)))_R of s'# { DEFAULT ->
                                            $wfoldlM'_loop
                                              GHC.Types.SPEC
                                              (GHC.Prim.+# ww5 1#)
                                              (GHC.Prim.+# ww6 1#)
                                              s'#
                                                `cast`
                                              (GHC.Prim.State#
                                                 (Control.Monad.Primitive.D:R:PrimStateST[0]
                                                      <GHC.Prim.RealWorld>_N))_R } }
                                         1# -> exit ww5 w2 } }
                                   } in
                                   $wfoldlM'_loop
                                     GHC.Types.SPEC
                                     0#
                                     0#
                                     ipv
                                       `cast`
                                     (GHC.Prim.State#
                                        (Control.Monad.Primitive.D:R:PrimStateST[0]
                                             <GHC.Prim.RealWorld>_N))_R }
                                1#
                                -> case Statistics.Matrix.fromRows5 ww3
                                   ret_ty (# GHC.Prim.State# GHC.Prim.RealWorld,
                                             Data.Vector.Unboxed.Base.Vector GHC.Types.Double #)
                                   of {} }
                           1#
                           -> case Statistics.Matrix.fromRows4 ww3
                              ret_ty (# GHC.Prim.State# GHC.Prim.RealWorld,
                                        Data.Vector.Unboxed.Base.Vector GHC.Types.Double #)
                              of {} }) of ds1 { (#,#) ipv1 ipv2 ->
                 case ipv2
                        `cast`
                      (Data.Vector.Unboxed.Base.D:R:VectorDouble0[0] ; Data.Vector.Unboxed.Base.N:R:VectorDouble[0]) of nt { Data.Vector.Primitive.Vector ipv ipv4 ipv5 ->
                 (# ww, ww1,
                    nt
                      `cast`
                    (Sym (Data.Vector.Unboxed.Base.N:R:VectorDouble[0]) ; Sym (Data.Vector.Unboxed.Base.D:R:VectorDouble0[0])) #) } }) -}
827cd42ef8220b7a9afd322bfdb4a87d
  $wmakeDecimal ::
    GHC.Word.Word8
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Prim.ByteArray#
    -> [[Data.Decimal.DecimalRaw GHC.Integer.Type.Integer]]
  {- Arity: 5, Strictness: <L,U(U)><S,U><S,U><S,U><S,U>, Inline: [2],
     Unfolding: (\ (w :: GHC.Word.Word8)
                   (ww :: GHC.Prim.Int#)
                   (ww1 :: GHC.Prim.Int#)
                   (ww2 :: GHC.Prim.Int#)
                   (ww3 :: GHC.Prim.ByteArray#) ->
                 let {
                   lvl3 :: GHC.Types.Double
                           -> Data.Decimal.DecimalRaw GHC.Integer.Type.Integer
                     {- Arity: 1, Strictness: <S(S),1*U(U)>m, Inline: [2],
                        Unfolding: InlineRule (1, True, False)
                                   (\ (w1 :: GHC.Types.Double) ->
                                    case w1 of ww4 { GHC.Types.D# ww5 ->
                                    case w of ww8 { GHC.Word.W8# ww9 ->
                                    case GHC.Real.^
                                           @ GHC.Types.Double
                                           @ GHC.Word.Word8
                                           Utils.makeDecimal2
                                           GHC.Word.$fIntegralWord8
                                           Utils.makeDecimal1
                                           ww8 of wild1 { GHC.Types.D# y ->
                                    case GHC.Float.$w$cround
                                           @ GHC.Integer.Type.Integer
                                           GHC.Real.$fIntegralInteger
                                           (GHC.Prim.*## ww5 y) of dt { DEFAULT ->
                                    Data.Decimal.Decimal
                                      @ GHC.Integer.Type.Integer
                                      ww9
                                      dt } } } }) -}
                   = \ (w1 :: GHC.Types.Double) ->
                     case w1 of ww4 { GHC.Types.D# ww5 ->
                     case w of ww8 { GHC.Word.W8# ww9 ->
                     case GHC.Real.^
                            @ GHC.Types.Double
                            @ GHC.Word.Word8
                            Utils.makeDecimal2
                            GHC.Word.$fIntegralWord8
                            Utils.makeDecimal1
                            ww8 of wild1 { GHC.Types.D# y ->
                     case GHC.Float.$w$cround
                            @ GHC.Integer.Type.Integer
                            GHC.Real.$fIntegralInteger
                            (GHC.Prim.*## ww5 y) of dt { DEFAULT ->
                     Data.Decimal.Decimal @ GHC.Integer.Type.Integer ww9 dt } } } }
                 } in
                 GHC.Base.map
                   @ [GHC.Types.Double]
                   @ [Data.Decimal.DecimalRaw GHC.Integer.Type.Integer]
                   (\ (ls :: [GHC.Types.Double]) ->
                    GHC.Base.map
                      @ GHC.Types.Double
                      @ (Data.Decimal.DecimalRaw GHC.Integer.Type.Integer)
                      lvl3
                      ls)
                   (Statistics.Matrix.$wtoRowLists ww ww1 ww2 ww3)) -}
3f001a8da4d516b304f835090d2a1508
  $wupperTriHelper ::
    Statistics.Matrix.Types.Matrix -> GHC.Prim.Int# -> GHC.Types.Bool
  {- Arity: 2, Strictness: <L,U(A,U,U(U,U,U))><S,U>, Inline: [2],
     Unfolding: (\ (w :: Statistics.Matrix.Types.Matrix)
                   (ww :: GHC.Prim.Int#) ->
                 let {
                   y :: GHC.Prim.Int# = GHC.Prim.-# ww 1#
                 } in
                 case GHC.Prim.># 0# y of lwild {
                   DEFAULT
                   -> let {
                        exit :: GHC.Prim.Int# -> GHC.Types.Bool -> GHC.Types.Bool
                          <join 2> {- Arity: 2, Strictness: <L,U><S,1*U> -}
                        = \ (x :: GHC.Prim.Int#)[OneShot] (v :: GHC.Types.Bool)[OneShot] ->
                          case v of wild {
                            GHC.Types.False -> GHC.Types.False
                            GHC.Types.True
                            -> case w of ww1 { Statistics.Matrix.Types.Matrix ww2 ww3 ww4 ->
                               case ww4
                                      `cast`
                                    (Data.Vector.Unboxed.Base.D:R:VectorDouble0[0] ; Data.Vector.Unboxed.Base.N:R:VectorDouble[0]) of ww5 { Data.Vector.Primitive.Vector ww6 ww7 ww8 ->
                               (Utils.$wisRowFromTriMatrix ww3 ww6 ww7 ww8 x)
                                 `cast`
                               (Data.Vector.Fusion.Util.N:Id[0] <GHC.Types.Bool>_R) } } }
                      } in
                      letrec {
                        go :: GHC.Prim.Int# -> GHC.Types.Bool -> GHC.Types.Bool
                          <join 2> {- Arity: 2, Strictness: <S,U><S,1*U> -}
                        = \ (x :: GHC.Prim.Int#) (v :: GHC.Types.Bool)[OneShot] ->
                          case GHC.Prim.==# x y of lwild1 {
                            DEFAULT
                            -> case v of wild {
                                 GHC.Types.False -> go (GHC.Prim.+# x 1#) GHC.Types.False
                                 GHC.Types.True
                                 -> case w of ww1 { Statistics.Matrix.Types.Matrix ww2 ww3 ww4 ->
                                    case ww4
                                           `cast`
                                         (Data.Vector.Unboxed.Base.D:R:VectorDouble0[0] ; Data.Vector.Unboxed.Base.N:R:VectorDouble[0]) of ww5 { Data.Vector.Primitive.Vector ww6 ww7 ww8 ->
                                    case Statistics.Matrix.$wrow
                                           ww3
                                           ww6
                                           ww7
                                           ww8
                                           x of ww10 { (#,,#) ww11 ww12 ww13 ->
                                    go
                                      (GHC.Prim.+# x 1#)
                                      (Utils.$whasLeadingZeros x ww11 ww12 ww13)
                                        `cast`
                                      (Data.Vector.Fusion.Util.N:Id[0] <GHC.Types.Bool>_R) } } } }
                            1# -> exit x v }
                      } in
                      go 0# GHC.Types.True
                   1# -> GHC.Types.True }) -}
9c4180e9c9756bafbfa7164d48306472
  det :: Statistics.Matrix.Types.Matrix -> GHC.Types.Double
  {- Arity: 1, Strictness: <S(LSS(SSS)),1*U(A,U,U(U,U,U))>,
     Unfolding: InlineRule (1, True, False)
                (\ (mat :: Statistics.Matrix.Types.Matrix) ->
                 Utils.det_detHelper (Statistics.Matrix.toRowLists mat)) -}
5010d692875c63f290ad0d133345bf69
  det_detHelper :: [[GHC.Types.Double]] -> GHC.Types.Double
  {- Arity: 1, Strictness: <S,U> -}
7e58c2cded1917622cc7d9c452d89e11
  getRest ::
    GHC.Types.Int -> [[GHC.Types.Double]] -> [[GHC.Types.Double]]
  {- Arity: 2, Strictness: <L,U(U)><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (col :: GHC.Types.Int) (mat :: [[GHC.Types.Double]]) ->
                 case mat of wild {
                   [] -> case GHC.List.scanl2 ret_ty [[GHC.Types.Double]] of {}
                   : ds1 xs
                   -> GHC.Base.build
                        @ [GHC.Types.Double]
                        (\ @ b1
                           (c :: [GHC.Types.Double] -> b1 -> b1)[OneShot]
                           (n :: b1)[OneShot] ->
                         GHC.Base.foldr
                           @ [GHC.Types.Double]
                           @ b1
                           (GHC.Base.mapFB
                              @ [GHC.Types.Double]
                              @ b1
                              @ [GHC.Types.Double]
                              c
                              (Utils.getRest_$sleaveElement col))
                           n
                           xs) }) -}
5f689caa8488f37053e2a374d49f23bc
  getRest_$sleaveElement ::
    GHC.Types.Int -> [GHC.Types.Double] -> [GHC.Types.Double]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(1*U)><S,1*U> -}
e28c87b712225303334f41d74b191ff3
  hasLeadingZeros ::
    GHC.Types.Int -> Statistics.Matrix.Types.Vector -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S),1*U(U)><S(SSS),1*U(U,U,U)>,
     Unfolding: InlineRule (0, True, True)
                Utils.hasLeadingZeros1
                  `cast`
                (<GHC.Types.Int>_R
                 ->_R <Statistics.Matrix.Types.Vector>_R
                 ->_R Data.Vector.Fusion.Util.N:Id[0] <GHC.Types.Bool>_R) -}
eb6584be2ad0b8e132a0a735f6271a25
  hasLeadingZeros1 ::
    GHC.Types.Int
    -> Statistics.Matrix.Types.Vector
    -> Data.Vector.Fusion.Util.Id GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S),1*U(U)><S(SSS),1*U(U,U,U)>, Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: GHC.Types.Int) (w1 :: Statistics.Matrix.Types.Vector) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1
                        `cast`
                      (Data.Vector.Unboxed.Base.D:R:VectorDouble0[0] ; Data.Vector.Unboxed.Base.N:R:VectorDouble[0]) of ww2 { Data.Vector.Primitive.Vector ww3 ww4 ww5 ->
                 Utils.$whasLeadingZeros ww1 ww3 ww4 ww5 } }) -}
897e9772f23678d8bc38e431be14728f
  isEqual ::
    GHC.Word.Word8
    -> Statistics.Matrix.Types.Matrix
    -> Statistics.Matrix.Types.Matrix
    -> GHC.Types.Bool
  {- Arity: 3,
     Strictness: <L,U(U)><S(LSS(SSS)),1*U(A,U,U(U,U,U))><S(LSS(SSS)),1*U(A,U,U(U,U,U))>,
     Unfolding: InlineRule (3, True, False)
                (\ (prec :: GHC.Word.Word8)
                   (a :: Statistics.Matrix.Types.Matrix)
                   (b :: Statistics.Matrix.Types.Matrix) ->
                 GHC.Classes.$fEq[]_$c==
                   @ [Data.Decimal.Decimal]
                   Utils.$s$fEq[]
                   (Utils.makeDecimal prec a)
                   (Utils.makeDecimal prec b)) -}
0dd285edcbcf0fadd14b0f9a2a542003
  isFloatZero ::
    GHC.Types.Double -> GHC.Types.Double -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S(S),1*U(U)><S(S),1*U(U)>,
     Unfolding: InlineRule (2, True, False)
                (\ (n :: GHC.Types.Double) (eps :: GHC.Types.Double) ->
                 case n of wild { GHC.Types.D# x ->
                 case eps of wild1 { GHC.Types.D# x1 ->
                 GHC.Prim.tagToEnum#
                   @ GHC.Types.Bool
                   (GHC.Prim.>##
                      (GHC.Prim.fabsDouble# x)
                      (GHC.Prim.fabsDouble# x1)) } }) -}
475ea65736b6957aa5e72643bbdfb7a5
  isInvertible :: Statistics.Matrix.Types.Matrix -> GHC.Types.Bool
  {- Arity: 1, Strictness: <S(LSS(SSS)),1*U(A,U,U(U,U,U))>,
     Unfolding: InlineRule (1, True, False)
                (\ (mat :: Statistics.Matrix.Types.Matrix) ->
                 case Utils.det_detHelper
                        (Statistics.Matrix.toRowLists mat) of wild { GHC.Types.D# x ->
                 GHC.Prim.tagToEnum#
                   @ GHC.Types.Bool
                   (GHC.Prim.>##
                      (GHC.Prim.fabsDouble# x)
                      (GHC.Prim.fabsDouble# 1.0e-7##)) }) -}
aa2622a53a1e38da6fe844d11abc2c65
  isOrtho :: Statistics.Matrix.Types.Matrix -> GHC.Types.Bool
  {- Arity: 1, Strictness: <S(SSS(SSS)),1*U(U,U,U(U,U,U))>,
     Inline: [2],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Statistics.Matrix.Types.Matrix) ->
                 case w of ww { Statistics.Matrix.Types.Matrix ww1 ww2 ww3 ->
                 case ww3
                        `cast`
                      (Data.Vector.Unboxed.Base.D:R:VectorDouble0[0] ; Data.Vector.Unboxed.Base.N:R:VectorDouble[0]) of ww4 { Data.Vector.Primitive.Vector ww5 ww6 ww7 ->
                 Utils.$wisOrtho ww1 ww2 ww5 ww6 ww7 } }) -}
dfc8441e9d0386313ec02f3434e02f98
  isOrtho1 :: [[Data.Decimal.Decimal]]
  {- Unfolding: (case Fixtures.matId of ww { Statistics.Matrix.Types.Matrix ww1 ww2 ww3 ->
                 case ww3
                        `cast`
                      (Data.Vector.Unboxed.Base.D:R:VectorDouble0[0] ; Data.Vector.Unboxed.Base.N:R:VectorDouble[0]) of ww4 { Data.Vector.Primitive.Vector ww5 ww6 ww7 ->
                 Utils.$wmakeDecimal Utils.isOrtho_prec ww2 ww5 ww6 ww7 } }) -}
4b1ada296abdaf8f244bf0fc02edf206
  isOrtho_prec :: GHC.Word.Word8
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Word.W8# 8##) -}
7bf7bcd6ca61395ba6a9fb663b395a3a
  isRowFromTriMatrix ::
    Statistics.Matrix.Types.Matrix -> GHC.Types.Int -> GHC.Types.Bool
  {- Arity: 2,
     Strictness: <S(LSS(SSS)),1*U(A,U,U(U,U,U))><S(S),1*U(U)>,
     Unfolding: InlineRule (0, True, True)
                Utils.isRowFromTriMatrix1
                  `cast`
                (<Statistics.Matrix.Types.Matrix>_R
                 ->_R <GHC.Types.Int>_R
                 ->_R Data.Vector.Fusion.Util.N:Id[0] <GHC.Types.Bool>_R) -}
df2adeeda651c58b10de286116aed9f5
  isRowFromTriMatrix1 ::
    Statistics.Matrix.Types.Matrix
    -> GHC.Types.Int -> Data.Vector.Fusion.Util.Id GHC.Types.Bool
  {- Arity: 2,
     Strictness: <S(LSS(SSS)),1*U(A,U,U(U,U,U))><S(S),1*U(U)>,
     Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Statistics.Matrix.Types.Matrix) (w1 :: GHC.Types.Int) ->
                 case w of ww { Statistics.Matrix.Types.Matrix ww1 ww2 ww3 ->
                 case ww3
                        `cast`
                      (Data.Vector.Unboxed.Base.D:R:VectorDouble0[0] ; Data.Vector.Unboxed.Base.N:R:VectorDouble[0]) of ww4 { Data.Vector.Primitive.Vector ww5 ww6 ww7 ->
                 case w1 of ww8 { GHC.Types.I# ww9 ->
                 Utils.$wisRowFromTriMatrix ww2 ww5 ww6 ww7 ww9 } } }) -}
aefc8064461ed5cd41510b38f80512c6
  isUpperTri :: Statistics.Matrix.Types.Matrix -> GHC.Types.Bool
  {- Arity: 1, Strictness: <S(SLS),1*U(U,U,U(U,U,U))>,
     Unfolding: InlineRule (1, True, False)
                (\ (mat :: Statistics.Matrix.Types.Matrix) ->
                 case mat of wild { Statistics.Matrix.Types.Matrix dt dt1 ds1 ->
                 Utils.upperTriHelper wild (GHC.Types.I# dt) }) -}
2a3ae1058322b3da88d4d4faa5408489
  leaveElement :: GHC.Classes.Ord a => GHC.Types.Int -> [a] -> [a]
  {- Arity: 3, HasNoCafRefs, Strictness: <L,A><L,1*U(1*U)><S,1*U>,
     Inline: [2],
     Unfolding: InlineRule (3, True, True)
                (\ @ a
                   (w :: GHC.Classes.Ord a)
                   (w1 :: GHC.Types.Int)
                   (w2 :: [a]) ->
                 Utils.$wleaveElement @ a w1 w2) -}
cb5fb7570200e67fdd4108684bbc0c62
  makeAbs ::
    Statistics.Matrix.Types.Matrix -> Statistics.Matrix.Types.Matrix
  {- Arity: 1, Strictness: <S(SSS(SSS)),1*U(U,U,U(U,U,U))>m,
     Inline: [2],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Statistics.Matrix.Types.Matrix) ->
                 case w of ww { Statistics.Matrix.Types.Matrix ww1 ww2 ww3 ->
                 case ww3
                        `cast`
                      (Data.Vector.Unboxed.Base.D:R:VectorDouble0[0] ; Data.Vector.Unboxed.Base.N:R:VectorDouble[0]) of ww4 { Data.Vector.Primitive.Vector ww5 ww6 ww7 ->
                 case Utils.$wmakeAbs
                        ww1
                        ww2
                        ww5
                        ww6
                        ww7 of ww8 { (#,,#) ww9 ww10 ww11 ->
                 Statistics.Matrix.Types.Matrix ww9 ww10 ww11 } } }) -}
087ba5743dbc6bfa7da932e17c841b04
  makeDecimal ::
    GHC.Word.Word8
    -> Statistics.Matrix.Types.Matrix -> [[Data.Decimal.Decimal]]
  {- Arity: 2, Strictness: <L,U(U)><S(LSS(SSS)),1*U(A,U,U(U,U,U))>,
     Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: GHC.Word.Word8) (w1 :: Statistics.Matrix.Types.Matrix) ->
                 case w1 of ww { Statistics.Matrix.Types.Matrix ww1 ww2 ww3 ->
                 case ww3
                        `cast`
                      (Data.Vector.Unboxed.Base.D:R:VectorDouble0[0] ; Data.Vector.Unboxed.Base.N:R:VectorDouble[0]) of ww4 { Data.Vector.Primitive.Vector ww5 ww6 ww7 ->
                 Utils.$wmakeDecimal w ww2 ww5 ww6 ww7 } }) -}
d8ea8b8aec84ce71e33a03ee4297db02
  makeDecimal1 :: GHC.Types.Double
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.D# 10.0##) -}
7029cf6cb1da8d0cb78ac8be70d0f2de
  makeDecimal2 :: GHC.Num.Num GHC.Types.Double
  {- Strictness: m,
     Unfolding: (GHC.Num.C:Num
                   @ GHC.Types.Double
                   (Data.Decimal.realFracToDecimal3 @ GHC.Types.Double)
                   (Data.Decimal.realFracToDecimal3 @ GHC.Types.Double)
                   GHC.Float.timesDouble
                   (Data.Decimal.realFracToDecimal1 @ GHC.Types.Double)
                   (Data.Decimal.realFracToDecimal1 @ GHC.Types.Double)
                   (Data.Decimal.realFracToDecimal1 @ GHC.Types.Double)
                   GHC.Float.$fNumDouble_$cfromInteger) -}
5265c27cc98f76a9ade31f37c564878f
  upperTriHelper ::
    Statistics.Matrix.Types.Matrix -> GHC.Types.Int -> GHC.Types.Bool
  {- Arity: 2, Strictness: <L,U(A,U,U(U,U,U))><S(S),1*U(U)>,
     Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Statistics.Matrix.Types.Matrix) (w1 :: GHC.Types.Int) ->
                 case w1 of ww { GHC.Types.I# ww1 ->
                 Utils.$wupperTriHelper w ww1 }) -}
"SPEC leaveElement @ Double" forall ($dOrd :: GHC.Classes.Ord
                                                GHC.Types.Double)
  Utils.leaveElement @ GHC.Types.Double $dOrd
  = Utils.getRest_$sleaveElement
"SPEC/Utils $fEqDecimalRaw @ Integer" [orphan] forall (v :: GHC.Real.Integral
                                                              GHC.Integer.Type.Integer)
  Data.Decimal.$fEqDecimalRaw @ GHC.Integer.Type.Integer v
  = Utils.$s$fEqDecimalRaw
"SPEC/Utils $fEqDecimalRaw_$c/= @ Integer" [orphan] forall ($dIntegral :: GHC.Real.Integral
                                                                            GHC.Integer.Type.Integer)
  Data.Decimal.$fEqDecimalRaw_$c/= @ GHC.Integer.Type.Integer
                                   $dIntegral
  = Utils.$s$fEqDecimalRaw_$s$fEqDecimalRaw_$c/=
"SPEC/Utils $fEq[] @ (DecimalRaw Integer)" [orphan] forall (v :: GHC.Classes.Eq
                                                                   (Data.Decimal.DecimalRaw
                                                                      GHC.Integer.Type.Integer))
  GHC.Classes.$fEq[] @ (Data.Decimal.DecimalRaw
                          GHC.Integer.Type.Integer)
                     v
  = Utils.$s$fEq[]
"SPEC/Utils $fEq[]_$c/= @ (DecimalRaw Integer)" [orphan] forall ($dEq :: GHC.Classes.Eq
                                                                           (Data.Decimal.DecimalRaw
                                                                              GHC.Integer.Type.Integer))
  GHC.Classes.$fEq[]_$c/= @ (Data.Decimal.DecimalRaw
                               GHC.Integer.Type.Integer)
                          $dEq
  = Utils.$s$fEq[]_$s$fEq[]_$c/=
trusted: none
require own pkg trusted: False
module header:
  Nothing
declaration docs:
arg docs:

