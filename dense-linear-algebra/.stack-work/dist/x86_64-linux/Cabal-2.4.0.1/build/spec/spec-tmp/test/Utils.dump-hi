
==================== FINAL INTERFACE ====================
2019-02-26 20:01:07.732673652 UTC

interface main:Utils 8063
  interface hash: d42a9e9acb32a002c1aa440ef7b3f278
  ABI hash: 9a09ef769e8af6712b2d4fd1c44705f1
  export-list hash: 1c8c094ee1ed51646dafd7dfe597a232
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 6e53648eade1ec3ffa724212f94d04d6
  opt_hash: 6faf2de08de32d19db9870899d88e59a
  hpc_hash: 93b885adfe0da089cdf634904fd59f71
  plugin_hash: ad164012d6b1e14942349d58b1132007
  sig of: Nothing
  used TH splices: False
  where
exports:
  Utils.det
  Utils.getRest
  Utils.hasLeadingZeros
  Utils.isFloatZero
  Utils.isInvertible
  Utils.isOrtho
  Utils.isRowFromTriMatrix
  Utils.isUpperTri
  Utils.leaveElement
  Utils.makeAbs
  Utils.upperTriHelper
module dependencies: Fixtures
package dependencies: array-0.5.3.0 base-4.12.0.0 deepseq-1.4.4.0
                      dense-linear-algebra-0.1.0.0 ghc-boot-th-8.6.3 ghc-prim-0.5.3
                      integer-gmp-1.0.2.0 math-functions-0.3.1.0 pretty-1.1.3.6
                      primitive-0.6.4.0 template-haskell-2.14.0.0 transformers-0.5.5.0
                      vector-0.12.0.2 vector-th-unbox-0.2.1.6
orphans: vector-0.12.0.2:Data.Vector.Unboxed
         vector-0.12.0.2:Data.Vector.Fusion.Bundle
         transformers-0.5.5.0:Control.Monad.Trans.Error
         base-4.12.0.0:GHC.Float base-4.12.0.0:GHC.Base
family instance modules: base-4.12.0.0:Control.Applicative
                         base-4.12.0.0:Data.Complex base-4.12.0.0:Data.Functor.Compose
                         base-4.12.0.0:Data.Functor.Const
                         base-4.12.0.0:Data.Functor.Identity
                         base-4.12.0.0:Data.Functor.Product base-4.12.0.0:Data.Functor.Sum
                         base-4.12.0.0:Data.Monoid base-4.12.0.0:Data.Semigroup
                         base-4.12.0.0:Data.Semigroup.Internal base-4.12.0.0:Data.Version
                         base-4.12.0.0:Data.Void base-4.12.0.0:GHC.Exts
                         base-4.12.0.0:GHC.Generics base-4.12.0.0:GHC.IO.Exception
                         ghc-boot-th-8.6.3:GHC.ForeignSrcLang.Type
                         ghc-boot-th-8.6.3:GHC.LanguageExtensions.Type
                         math-functions-0.3.1.0:Numeric.Sum
                         pretty-1.1.3.6:Text.PrettyPrint.Annotated.HughesPJ
                         pretty-1.1.3.6:Text.PrettyPrint.HughesPJ
                         primitive-0.6.4.0:Control.Monad.Primitive
                         primitive-0.6.4.0:Data.Primitive.Array
                         primitive-0.6.4.0:Data.Primitive.ByteArray
                         primitive-0.6.4.0:Data.Primitive.PrimArray
                         primitive-0.6.4.0:Data.Primitive.SmallArray
                         primitive-0.6.4.0:Data.Primitive.UnliftedArray
                         template-haskell-2.14.0.0:Language.Haskell.TH.Syntax
                         vector-0.12.0.2:Data.Vector vector-0.12.0.2:Data.Vector.Primitive
                         vector-0.12.0.2:Data.Vector.Unboxed
                         vector-0.12.0.2:Data.Vector.Unboxed.Base
import  -/  base-4.12.0.0:Data.Foldable 00188ddf89c975fee76bdfad479443c1
import  -/  base-4.12.0.0:Data.Tuple c92a835d04b6c075a7031d4e28e53c71
import  -/  base-4.12.0.0:GHC.Base cc906f98291a1b830546e99a96674547
import  -/  base-4.12.0.0:GHC.List 734a72beb76d276fb4a0ba2689a5711f
import  -/  base-4.12.0.0:GHC.Num 847723f2584d989dac1eada133ac3fb8
import  -/  base-4.12.0.0:GHC.Real f7dad82c1d43d80823865d3e6c6636e0
import  -/  base-4.12.0.0:Prelude 5c01365ec01f83bd405ac01cbb9a8d76
import  -/  dense-linear-algebra-0.1.0.0:Statistics.Matrix 13ab77e285f81007796591ea79278ec9
import  -/  dense-linear-algebra-0.1.0.0:Statistics.Matrix.Algorithms 0835d6573d6ef10889d7f05e0b129662
import  -/  dense-linear-algebra-0.1.0.0:Statistics.Matrix.Function 1ff23262872805be3e37b5f602ab6100
import  -/  dense-linear-algebra-0.1.0.0:Statistics.Matrix.Mutable 402a1a0245fa0422f2ee5f0ada7b52e1
import  -/  dense-linear-algebra-0.1.0.0:Statistics.Matrix.Types 7a9ae1dc0a9192be182b9686b68c4c9c
import  -/  ghc-prim-0.5.3:GHC.Classes e0d9c979f6368701f34fa421754d2cce
import  -/  Fixtures 075e2e5a008ab59e398fd4047f9d7233
  exports: 497315acd469bbe0ee26b13b90f5fc27
  matId 294d9b36e9c0e890e8f7ad036524d7c8
import  -/  vector-0.12.0.2:Data.Vector.Unboxed 3ec9008297a7b27b6fe569e181327338
a12658d0a681752c98cb3fc6d3fc5852
  $s^1 :: GHC.Types.Double
  {- Strictness: x -}
6e4cfbbe250611482ac08c6d558f4dce
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module Utils.$trModule3 Utils.$trModule1) -}
6ea2ae0a946ba28d3e9a92ae079dc36e
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Utils.$trModule2) -}
c81636fcbf58b412e558c29d269dd105
  $trModule2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Utils"#) -}
48e9693c199df8b405168bfddb9c283b
  $trModule3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Utils.$trModule4) -}
be56da26131302c822ff452d3bc5ec6f
  $trModule4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("main"#) -}
d0605579bb34dcd3090af002be911d84
  $wf :: GHC.Prim.Double# -> GHC.Prim.Int# -> GHC.Prim.Double#
  {- Arity: 2, HasNoCafRefs, Strictness: <S,U><S,U>, Inline: [2] -}
189c7737a76f07e50d3270b62648e711
  $whasLeadingZeros ::
    GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Prim.ByteArray#
    -> Data.Vector.Fusion.Util.Id GHC.Types.Bool
  {- Arity: 4, HasNoCafRefs, Strictness: <S,U><L,U><S,U><L,U>,
     Inline: [2],
     Unfolding: (\ (ww :: GHC.Prim.Int#)
                   (ww1 :: GHC.Prim.Int#)
                   (ww2 :: GHC.Prim.Int#)
                   (ww3 :: GHC.Prim.ByteArray#) ->
                 let {
                   $w$j :: GHC.Prim.Int# -> Data.Vector.Fusion.Util.Id GHC.Types.Bool
                     <join 1> {- Arity: 1, Strictness: <S,U>, Inline: [2] -}
                   = \ (w :: GHC.Prim.Int#)[OneShot] ->
                     let {
                       $j :: GHC.Prim.Int# -> Data.Vector.Fusion.Util.Id GHC.Types.Bool
                         <join 1> {- Arity: 1, Strictness: <S,U> -}
                       = \ (dt :: GHC.Prim.Int#)[OneShot] ->
                         letrec {
                           $wfoldlM_loop :: GHC.Types.SPEC
                                            -> GHC.Types.Bool
                                            -> GHC.Prim.Int#
                                            -> Data.Vector.Fusion.Util.Id GHC.Types.Bool
                             <join 3> {- Arity: 3, Strictness: <S,1*U><S,1*U><S,U>,
                                         Inline: [2] -}
                           = \ (w1 :: GHC.Types.SPEC)
                               (w2 :: GHC.Types.Bool)
                               (ww4 :: GHC.Prim.Int#) ->
                             case w1 of ds5 { DEFAULT ->
                             case GHC.Prim.>=# ww4 dt of lwild {
                               DEFAULT
                               -> case GHC.Prim.indexDoubleArray#
                                         ww3
                                         (GHC.Prim.+# ww1 ww4) of wild2 { DEFAULT ->
                                  case w2 of wild {
                                    GHC.Types.False
                                    -> $wfoldlM_loop
                                         GHC.Types.SPEC
                                         GHC.Types.False
                                         (GHC.Prim.+# ww4 1#)
                                    GHC.Types.True
                                    -> $wfoldlM_loop
                                         GHC.Types.SPEC
                                         (GHC.Prim.tagToEnum#
                                            @ GHC.Types.Bool
                                            (GHC.Prim.==## wild2 0.0##))
                                         (GHC.Prim.+# ww4 1#) } }
                               1#
                               -> w2
                                    `cast`
                                  (Sym (Data.Vector.Fusion.Util.N:Id[0] <GHC.Types.Bool>_R)) } }
                         } in
                         $wfoldlM_loop GHC.Types.SPEC GHC.Types.True 0#
                     } in
                     case GHC.Prim.<=# w ww2 of lwild { DEFAULT -> $j ww2 1# -> $j w }
                 } in
                 case GHC.Prim.<=# ww 0# of lwild {
                   DEFAULT -> $w$j ww 1# -> $w$j 0# }) -}
9dd0140c7cb7bafa3eb5b819c42dac1b
  $wisOrtho ::
    GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Prim.ByteArray#
    -> GHC.Types.Bool
  {- Arity: 5, Strictness: <S,U><S,U><S,U><S,U><S,U>, Inline: [2],
     Unfolding: (\ (ww :: GHC.Prim.Int#)
                   (ww1 :: GHC.Prim.Int#)
                   (ww2 :: GHC.Prim.Int#)
                   (ww3 :: GHC.Prim.Int#)
                   (ww4 :: GHC.Prim.ByteArray#) ->
                 case Statistics.Matrix.$wtranspose
                        ww
                        ww1
                        ww2
                        ww4 of ww8 { (#,,#) ww9 ww10 ww11 ->
                 case ww11
                        `cast`
                      (Data.Vector.Unboxed.Base.D:R:VectorDouble0[0] ; Data.Vector.Unboxed.Base.N:R:VectorDouble[0]) of ww12 { Data.Vector.Primitive.Vector ww13 ww14 ww15 ->
                 case Statistics.Matrix.$wmultiply
                        ww
                        ww1
                        ww2
                        ww3
                        ww4
                        ww9
                        ww10
                        ww13
                        ww14
                        ww15 of ww16 { (#,,#) ww17 ww18 ww19 ->
                 case ww19
                        `cast`
                      (Data.Vector.Unboxed.Base.D:R:VectorDouble0[0] ; Data.Vector.Unboxed.Base.N:R:VectorDouble[0]) of ww5 { Data.Vector.Primitive.Vector ww6 ww7 ww23 ->
                 case Fixtures.matId of ww24 { Statistics.Matrix.Types.Matrix ww25 ww26 ww27 ->
                 case ww27
                        `cast`
                      (Data.Vector.Unboxed.Base.D:R:VectorDouble0[0] ; Data.Vector.Unboxed.Base.N:R:VectorDouble[0]) of ww28 { Data.Vector.Primitive.Vector ww29 ww30 ww31 ->
                 Statistics.Matrix.Types.$w$c==
                   ww17
                   ww18
                   ww6
                   ww7
                   ww23
                   ww25
                   ww26
                   ww29
                   ww30
                   ww31 } } } } } }) -}
abcd35ecece070621cf6a63716429d80
  $wisRowFromTriMatrix ::
    GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Prim.ByteArray#
    -> GHC.Prim.Int#
    -> Data.Vector.Fusion.Util.Id GHC.Types.Bool
  {- Arity: 5, Strictness: <S,U><S,U><S,U><S,U><S,U>, Inline: [2],
     Unfolding: (\ (ww :: GHC.Prim.Int#)
                   (ww1 :: GHC.Prim.Int#)
                   (ww2 :: GHC.Prim.Int#)
                   (ww3 :: GHC.Prim.ByteArray#)
                   (ww4 :: GHC.Prim.Int#) ->
                 case Statistics.Matrix.$wrow
                        ww
                        ww1
                        ww2
                        ww3
                        ww4 of ww10 { (#,,#) ww11 ww12 ww13 ->
                 Utils.$whasLeadingZeros ww4 ww11 ww12 ww13 }) -}
cb6a799062884b8317a51d3913495b91
  $wleaveElement :: GHC.Types.Int -> [a] -> [a]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(1*U)><S,1*U>,
     Inline: [2] -}
98a888f9d1dc5d0237aec2972d024910
  $wmakeAbs ::
    GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Prim.ByteArray#
    -> (# GHC.Prim.Int#, GHC.Prim.Int#,
          Statistics.Matrix.Types.Vector #)
  {- Arity: 5, Strictness: <L,U><L,U><L,U><S,U><L,U>, Inline: [2],
     Unfolding: (\ (ww :: GHC.Prim.Int#)
                   (ww1 :: GHC.Prim.Int#)
                   (ww2 :: GHC.Prim.Int#)
                   (ww3 :: GHC.Prim.Int#)
                   (ww4 :: GHC.Prim.ByteArray#) ->
                 case GHC.Magic.runRW#
                        @ ('GHC.Types.TupleRep
                             '[ 'GHC.Types.TupleRep '[], 'GHC.Types.LiftedRep])
                        @ (# GHC.Prim.State# GHC.Prim.RealWorld,
                             Data.Vector.Unboxed.Base.Vector GHC.Types.Double #)
                        (\ (s1 :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                         case GHC.Prim.<# ww3 0# of lwild {
                           DEFAULT
                           -> case GHC.Prim.># ww3 1152921504606846975# of lwild1 {
                                DEFAULT
                                -> case GHC.Prim.newByteArray#
                                          @ (Control.Monad.Primitive.PrimState
                                               (GHC.ST.ST GHC.Prim.RealWorld))
                                          (GHC.Prim.*# ww3 8#)
                                          s1
                                            `cast`
                                          (GHC.Prim.State#
                                             (Sym (Control.Monad.Primitive.D:R:PrimStateST[0]
                                                       <GHC.Prim.RealWorld>_N)))_R of ds1 { (#,#) ipv ipv1 ->
                                   let {
                                     exit :: GHC.Prim.Int#
                                             -> GHC.Prim.State# GHC.Prim.RealWorld
                                             -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                                   Data.Vector.Unboxed.Base.Vector
                                                     GHC.Types.Double #)
                                       <join 2> {- Arity: 2, Strictness: <L,U><S,U> -}
                                     = \ (ww5 :: GHC.Prim.Int#)[OneShot]
                                         (w1 :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                                       case GHC.Prim.unsafeFreezeByteArray#
                                              @ (Control.Monad.Primitive.PrimState
                                                   (GHC.ST.ST GHC.Prim.RealWorld))
                                              ipv1
                                              w1
                                                `cast`
                                              (GHC.Prim.State#
                                                 (Sym (Control.Monad.Primitive.D:R:PrimStateST[0]
                                                           <GHC.Prim.RealWorld>_N)))_R of ds2 { (#,#) ipv2 ipv3 ->
                                       (# ipv2
                                            `cast`
                                          (GHC.Prim.State#
                                             (Control.Monad.Primitive.D:R:PrimStateST[0]
                                                  <GHC.Prim.RealWorld>_N))_R,
                                          (Data.Vector.Primitive.Vector
                                             @ GHC.Types.Double
                                             0#
                                             ww5
                                             ipv3)
                                            `cast`
                                          (Sym (Data.Vector.Unboxed.Base.N:R:VectorDouble[0]) ; Sym (Data.Vector.Unboxed.Base.D:R:VectorDouble0[0])) #) }
                                   } in
                                   letrec {
                                     $wfoldlM'_loop :: GHC.Types.SPEC
                                                       -> GHC.Prim.Int#
                                                       -> GHC.Prim.Int#
                                                       -> GHC.Prim.State# GHC.Prim.RealWorld
                                                       -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                                             Data.Vector.Unboxed.Base.Vector
                                                               GHC.Types.Double #)
                                       <join 4> {- Arity: 4, Strictness: <S,1*U><S,U><S,U><S,U>,
                                                   Inline: [2] -}
                                     = \ (w1 :: GHC.Types.SPEC)
                                         (ww5 :: GHC.Prim.Int#)
                                         (ww6 :: GHC.Prim.Int#)
                                         (w2 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                                       case w1 of ds5 { DEFAULT ->
                                       case GHC.Prim.>=# ww6 ww3 of lwild2 {
                                         DEFAULT
                                         -> case GHC.Prim.indexDoubleArray#
                                                   ww4
                                                   (GHC.Prim.+# ww2 ww6) of wild2 { DEFAULT ->
                                            case GHC.Prim.writeDoubleArray#
                                                   @ (Control.Monad.Primitive.PrimState
                                                        (GHC.ST.ST GHC.Prim.RealWorld))
                                                   ipv1
                                                   ww5
                                                   (GHC.Prim.fabsDouble# wild2)
                                                   w2
                                                     `cast`
                                                   (GHC.Prim.State#
                                                      (Sym (Control.Monad.Primitive.D:R:PrimStateST[0]
                                                                <GHC.Prim.RealWorld>_N)))_R of s'# { DEFAULT ->
                                            $wfoldlM'_loop
                                              GHC.Types.SPEC
                                              (GHC.Prim.+# ww5 1#)
                                              (GHC.Prim.+# ww6 1#)
                                              s'#
                                                `cast`
                                              (GHC.Prim.State#
                                                 (Control.Monad.Primitive.D:R:PrimStateST[0]
                                                      <GHC.Prim.RealWorld>_N))_R } }
                                         1# -> exit ww5 w2 } }
                                   } in
                                   $wfoldlM'_loop
                                     GHC.Types.SPEC
                                     0#
                                     0#
                                     ipv
                                       `cast`
                                     (GHC.Prim.State#
                                        (Control.Monad.Primitive.D:R:PrimStateST[0]
                                             <GHC.Prim.RealWorld>_N))_R }
                                1#
                                -> case Statistics.Matrix.fromRows5 ww3
                                   ret_ty (# GHC.Prim.State# GHC.Prim.RealWorld,
                                             Data.Vector.Unboxed.Base.Vector GHC.Types.Double #)
                                   of {} }
                           1#
                           -> case Statistics.Matrix.fromRows4 ww3
                              ret_ty (# GHC.Prim.State# GHC.Prim.RealWorld,
                                        Data.Vector.Unboxed.Base.Vector GHC.Types.Double #)
                              of {} }) of ds1 { (#,#) ipv1 ipv2 ->
                 case ipv2
                        `cast`
                      (Data.Vector.Unboxed.Base.D:R:VectorDouble0[0] ; Data.Vector.Unboxed.Base.N:R:VectorDouble[0]) of nt { Data.Vector.Primitive.Vector ipv ipv4 ipv5 ->
                 (# ww, ww1,
                    nt
                      `cast`
                    (Sym (Data.Vector.Unboxed.Base.N:R:VectorDouble[0]) ; Sym (Data.Vector.Unboxed.Base.D:R:VectorDouble0[0])) #) } }) -}
c647cb3424d5a7242c01ae443d3d9dba
  $wupperTriHelper ::
    Statistics.Matrix.Types.Matrix -> GHC.Prim.Int# -> GHC.Types.Bool
  {- Arity: 2, Strictness: <L,U(A,U,U(U,U,U))><S,U>, Inline: [2],
     Unfolding: (\ (w :: Statistics.Matrix.Types.Matrix)
                   (ww :: GHC.Prim.Int#) ->
                 let {
                   y :: GHC.Prim.Int# = GHC.Prim.-# ww 1#
                 } in
                 case GHC.Prim.># 0# y of lwild {
                   DEFAULT
                   -> let {
                        exit :: GHC.Prim.Int# -> GHC.Types.Bool -> GHC.Types.Bool
                          <join 2> {- Arity: 2, Strictness: <L,U><S,1*U> -}
                        = \ (x :: GHC.Prim.Int#)[OneShot] (v :: GHC.Types.Bool)[OneShot] ->
                          case v of wild {
                            GHC.Types.False -> GHC.Types.False
                            GHC.Types.True
                            -> case w of ww1 { Statistics.Matrix.Types.Matrix ww2 ww3 ww4 ->
                               case ww4
                                      `cast`
                                    (Data.Vector.Unboxed.Base.D:R:VectorDouble0[0] ; Data.Vector.Unboxed.Base.N:R:VectorDouble[0]) of ww5 { Data.Vector.Primitive.Vector ww6 ww7 ww8 ->
                               (Utils.$wisRowFromTriMatrix ww3 ww6 ww7 ww8 x)
                                 `cast`
                               (Data.Vector.Fusion.Util.N:Id[0] <GHC.Types.Bool>_R) } } }
                      } in
                      letrec {
                        go :: GHC.Prim.Int# -> GHC.Types.Bool -> GHC.Types.Bool
                          <join 2> {- Arity: 2, Strictness: <S,U><S,1*U> -}
                        = \ (x :: GHC.Prim.Int#) (v :: GHC.Types.Bool)[OneShot] ->
                          case GHC.Prim.==# x y of lwild1 {
                            DEFAULT
                            -> case v of wild {
                                 GHC.Types.False -> go (GHC.Prim.+# x 1#) GHC.Types.False
                                 GHC.Types.True
                                 -> case w of ww1 { Statistics.Matrix.Types.Matrix ww2 ww3 ww4 ->
                                    case ww4
                                           `cast`
                                         (Data.Vector.Unboxed.Base.D:R:VectorDouble0[0] ; Data.Vector.Unboxed.Base.N:R:VectorDouble[0]) of ww5 { Data.Vector.Primitive.Vector ww6 ww7 ww8 ->
                                    case Statistics.Matrix.$wrow
                                           ww3
                                           ww6
                                           ww7
                                           ww8
                                           x of ww10 { (#,,#) ww11 ww12 ww13 ->
                                    go
                                      (GHC.Prim.+# x 1#)
                                      (Utils.$whasLeadingZeros x ww11 ww12 ww13)
                                        `cast`
                                      (Data.Vector.Fusion.Util.N:Id[0] <GHC.Types.Bool>_R) } } } }
                            1# -> exit x v }
                      } in
                      go 0# GHC.Types.True
                   1# -> GHC.Types.True }) -}
c2366f00fe3b7aaae1052053f18fd5c4
  det :: Statistics.Matrix.Types.Matrix -> GHC.Types.Double
  {- Arity: 1, Strictness: <S(LSS(SSS)),1*U(A,U,U(U,U,U))>,
     Unfolding: InlineRule (1, True, False)
                (\ (mat :: Statistics.Matrix.Types.Matrix) ->
                 Utils.det_detHelper (Statistics.Matrix.toRowLists mat)) -}
5010d692875c63f290ad0d133345bf69
  det_detHelper :: [[GHC.Types.Double]] -> GHC.Types.Double
  {- Arity: 1, Strictness: <S,U> -}
7e58c2cded1917622cc7d9c452d89e11
  getRest ::
    GHC.Types.Int -> [[GHC.Types.Double]] -> [[GHC.Types.Double]]
  {- Arity: 2, Strictness: <L,U(U)><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (col :: GHC.Types.Int) (mat :: [[GHC.Types.Double]]) ->
                 case mat of wild {
                   [] -> case GHC.List.scanl2 ret_ty [[GHC.Types.Double]] of {}
                   : ds1 xs
                   -> GHC.Base.build
                        @ [GHC.Types.Double]
                        (\ @ b1
                           (c :: [GHC.Types.Double] -> b1 -> b1)[OneShot]
                           (n :: b1)[OneShot] ->
                         GHC.Base.foldr
                           @ [GHC.Types.Double]
                           @ b1
                           (GHC.Base.mapFB
                              @ [GHC.Types.Double]
                              @ b1
                              @ [GHC.Types.Double]
                              c
                              (Utils.getRest_$sleaveElement col))
                           n
                           xs) }) -}
5f689caa8488f37053e2a374d49f23bc
  getRest_$sleaveElement ::
    GHC.Types.Int -> [GHC.Types.Double] -> [GHC.Types.Double]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(1*U)><S,1*U> -}
ab3517243ec10ee720da4fb90881a910
  hasLeadingZeros ::
    GHC.Types.Int -> Statistics.Matrix.Types.Vector -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S),1*U(U)><S(SSS),1*U(U,U,U)>,
     Unfolding: InlineRule (0, True, True)
                Utils.hasLeadingZeros1
                  `cast`
                (<GHC.Types.Int>_R
                 ->_R <Statistics.Matrix.Types.Vector>_R
                 ->_R Data.Vector.Fusion.Util.N:Id[0] <GHC.Types.Bool>_R) -}
79940c90b31867856a9b247e11ca1a03
  hasLeadingZeros1 ::
    GHC.Types.Int
    -> Statistics.Matrix.Types.Vector
    -> Data.Vector.Fusion.Util.Id GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S),1*U(U)><S(SSS),1*U(U,U,U)>, Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: GHC.Types.Int) (w1 :: Statistics.Matrix.Types.Vector) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1
                        `cast`
                      (Data.Vector.Unboxed.Base.D:R:VectorDouble0[0] ; Data.Vector.Unboxed.Base.N:R:VectorDouble[0]) of ww2 { Data.Vector.Primitive.Vector ww3 ww4 ww5 ->
                 Utils.$whasLeadingZeros ww1 ww3 ww4 ww5 } }) -}
0dd285edcbcf0fadd14b0f9a2a542003
  isFloatZero ::
    GHC.Types.Double -> GHC.Types.Double -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S(S),1*U(U)><S(S),1*U(U)>,
     Unfolding: InlineRule (2, True, False)
                (\ (n :: GHC.Types.Double) (eps :: GHC.Types.Double) ->
                 case n of wild { GHC.Types.D# x ->
                 case eps of wild1 { GHC.Types.D# x1 ->
                 GHC.Prim.tagToEnum#
                   @ GHC.Types.Bool
                   (GHC.Prim.>##
                      (GHC.Prim.fabsDouble# x)
                      (GHC.Prim.fabsDouble# x1)) } }) -}
c6fc5364f02aea93688758ee2f8fee12
  isInvertible :: Statistics.Matrix.Types.Matrix -> GHC.Types.Bool
  {- Arity: 1, Strictness: <S(LSS(SSS)),1*U(A,U,U(U,U,U))>,
     Unfolding: InlineRule (1, True, False)
                (\ (mat :: Statistics.Matrix.Types.Matrix) ->
                 case Utils.det_detHelper
                        (Statistics.Matrix.toRowLists mat) of wild { GHC.Types.D# x ->
                 GHC.Prim.tagToEnum#
                   @ GHC.Types.Bool
                   (GHC.Prim.>##
                      (GHC.Prim.fabsDouble# x)
                      (GHC.Prim.fabsDouble# 1.0e-7##)) }) -}
f5d79080ace3cf84a89039b112fee2a4
  isOrtho :: Statistics.Matrix.Types.Matrix -> GHC.Types.Bool
  {- Arity: 1, Strictness: <S(SSS(SSS)),1*U(U,U,U(U,U,U))>,
     Inline: [2],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Statistics.Matrix.Types.Matrix) ->
                 case w of ww { Statistics.Matrix.Types.Matrix ww1 ww2 ww3 ->
                 case ww3
                        `cast`
                      (Data.Vector.Unboxed.Base.D:R:VectorDouble0[0] ; Data.Vector.Unboxed.Base.N:R:VectorDouble[0]) of ww4 { Data.Vector.Primitive.Vector ww5 ww6 ww7 ->
                 Utils.$wisOrtho ww1 ww2 ww5 ww6 ww7 } }) -}
1f99dbe22945c9ba12dc8469202b2ee8
  isRowFromTriMatrix ::
    Statistics.Matrix.Types.Matrix -> GHC.Types.Int -> GHC.Types.Bool
  {- Arity: 2,
     Strictness: <S(LSS(SSS)),1*U(A,U,U(U,U,U))><S(S),1*U(U)>,
     Unfolding: InlineRule (0, True, True)
                Utils.isRowFromTriMatrix1
                  `cast`
                (<Statistics.Matrix.Types.Matrix>_R
                 ->_R <GHC.Types.Int>_R
                 ->_R Data.Vector.Fusion.Util.N:Id[0] <GHC.Types.Bool>_R) -}
15312fde4f47c91cee663288f8e7e6c9
  isRowFromTriMatrix1 ::
    Statistics.Matrix.Types.Matrix
    -> GHC.Types.Int -> Data.Vector.Fusion.Util.Id GHC.Types.Bool
  {- Arity: 2,
     Strictness: <S(LSS(SSS)),1*U(A,U,U(U,U,U))><S(S),1*U(U)>,
     Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Statistics.Matrix.Types.Matrix) (w1 :: GHC.Types.Int) ->
                 case w of ww { Statistics.Matrix.Types.Matrix ww1 ww2 ww3 ->
                 case ww3
                        `cast`
                      (Data.Vector.Unboxed.Base.D:R:VectorDouble0[0] ; Data.Vector.Unboxed.Base.N:R:VectorDouble[0]) of ww4 { Data.Vector.Primitive.Vector ww5 ww6 ww7 ->
                 case w1 of ww8 { GHC.Types.I# ww9 ->
                 Utils.$wisRowFromTriMatrix ww2 ww5 ww6 ww7 ww9 } } }) -}
5ee64341349c160267eaa8ae7a3b7945
  isUpperTri :: Statistics.Matrix.Types.Matrix -> GHC.Types.Bool
  {- Arity: 1, Strictness: <S(SLS),1*U(U,U,U(U,U,U))>,
     Unfolding: InlineRule (1, True, False)
                (\ (mat :: Statistics.Matrix.Types.Matrix) ->
                 case mat of wild { Statistics.Matrix.Types.Matrix dt dt1 ds1 ->
                 Utils.upperTriHelper wild (GHC.Types.I# dt) }) -}
2a3ae1058322b3da88d4d4faa5408489
  leaveElement :: GHC.Classes.Ord a => GHC.Types.Int -> [a] -> [a]
  {- Arity: 3, HasNoCafRefs, Strictness: <L,A><L,1*U(1*U)><S,1*U>,
     Inline: [2],
     Unfolding: InlineRule (3, True, True)
                (\ @ a
                   (w :: GHC.Classes.Ord a)
                   (w1 :: GHC.Types.Int)
                   (w2 :: [a]) ->
                 Utils.$wleaveElement @ a w1 w2) -}
19dd35e3596b2342515db410e7d49c8e
  makeAbs ::
    Statistics.Matrix.Types.Matrix -> Statistics.Matrix.Types.Matrix
  {- Arity: 1, Strictness: <S(SSS(SSS)),1*U(U,U,U(U,U,U))>m,
     Inline: [2],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Statistics.Matrix.Types.Matrix) ->
                 case w of ww { Statistics.Matrix.Types.Matrix ww1 ww2 ww3 ->
                 case ww3
                        `cast`
                      (Data.Vector.Unboxed.Base.D:R:VectorDouble0[0] ; Data.Vector.Unboxed.Base.N:R:VectorDouble[0]) of ww4 { Data.Vector.Primitive.Vector ww5 ww6 ww7 ->
                 case Utils.$wmakeAbs
                        ww1
                        ww2
                        ww5
                        ww6
                        ww7 of ww8 { (#,,#) ww9 ww10 ww11 ->
                 Statistics.Matrix.Types.Matrix ww9 ww10 ww11 } } }) -}
a22bf7c1f16fcce66f385690de61a3bd
  upperTriHelper ::
    Statistics.Matrix.Types.Matrix -> GHC.Types.Int -> GHC.Types.Bool
  {- Arity: 2, Strictness: <L,U(A,U,U(U,U,U))><S(S),1*U(U)>,
     Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Statistics.Matrix.Types.Matrix) (w1 :: GHC.Types.Int) ->
                 case w1 of ww { GHC.Types.I# ww1 ->
                 Utils.$wupperTriHelper w ww1 }) -}
"SPEC leaveElement @ Double" forall ($dOrd :: GHC.Classes.Ord
                                                GHC.Types.Double)
  Utils.leaveElement @ GHC.Types.Double $dOrd
  = Utils.getRest_$sleaveElement
trusted: none
require own pkg trusted: False
module header:
  Nothing
declaration docs:
arg docs:

